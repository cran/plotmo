> # test.non.earth.R: test plotmo on non-earth models
> # Stephen Milborrow, Basley KwaZulu-Natal Mar 2011
> 
> library(plotmo)
Loading required package: plotrix
Loading required package: TeachingDemos
> library(earth)
> data(ozone1)
> data(etitanic)
> options(warn=1) # print warnings as they occur
> if(!interactive())
+     postscript(paper="letter")
> dopar <- function(nrows, ncols, caption = "")
+ {
+     cat("                             ", caption, "\n")
+     par(mfrow=c(nrows, ncols))
+     par(oma = c(0, 0, 3, 0))
+     par(mar = c(3, 3, 1.7, 0.5))
+     par(mgp = c(1.6, 0.6, 0))
+     par(cex = 0.7)
+ }
> expect.err <- function(obj) # test that we got an error as expected from a try() call
+ {
+     if(class(obj)[1] == "try-error")
+         cat("Got error as expected\n")
+     else
+         stop("did not get expected error")
+ }
> caption <- "test lm(log(doy) ~ vh+wind+humidity+temp+log(ibh), data=ozone1)"
> dopar(4,5,caption)
                              test lm(log(doy) ~ vh+wind+humidity+temp+log(ibh), data=ozone1) 
> a <- lm(log(doy) ~ vh + wind + humidity + temp + log(ibh), data=ozone1)
> plotmo(a, do.par=FALSE, caption=caption, ylim=NA, col.response=3, pt.pch=20, smooth.col="indianred")
> termplot(a)
> 
> caption <- "test lm(log(doy) ~ vh+wind+humidity+I(wind*humidity)+temp+log(ibh), data=ozone1)"
> dopar(4,5,caption)
                              test lm(log(doy) ~ vh+wind+humidity+I(wind*humidity)+temp+log(ibh), data=ozone1) 
> a <- lm(log(doy) ~ vh + wind + humidity + temp + log(ibh), data=ozone1)
> plotmo(a, do.par=FALSE, caption=caption, ylim=NA, col.resp=3, pt.pch=20, clip=FALSE, smooth.col="indianred")
> termplot(a)
> 
> caption <- "test lm(doy ~ (vh+wind+humidity)^2, data=ozone1)"
> dopar(4,3,caption)
                              test lm(doy ~ (vh+wind+humidity)^2, data=ozone1) 
> a <- lm(doy ~ (vh+wind+humidity)^2, data=ozone1)
> plotmo(a, do.par=FALSE, caption=caption, ylim=NULL)
 grid:    vh wind humidity
        5760    5       64
> # termplot(a) # termplot fails with Error in `[.data.frame`(mf, , i): undefined columns selected
> 
> caption <- "test lm(doy^2 ~ vh+wind+humidity+I(wind*humidity)+temp+log(ibh), data=ozone1)"
> dopar(4,3,caption)
                              test lm(doy^2 ~ vh+wind+humidity+I(wind*humidity)+temp+log(ibh), data=ozone1) 
> a <- lm(doy^2 ~ vh+wind+humidity+I(wind*humidity)+temp+log(ibh), data=ozone1)
> plotmo(a, do.par=FALSE, caption=caption, ylim=NULL)
 grid:    vh wind humidity temp    ibh
        5760    5       64   62 2112.5
> termplot(a) # termplot draws a funky second wind plot
> 
> caption <- "test lm with data=ozone versus attach(ozone)"
> dopar(4,3,caption)
                              test lm with data=ozone versus attach(ozone) 
> a <- lm(log(doy) ~ I(vh*wind) + wind + I(humidity*temp) + log(ibh), data=ozone1)
> plotmo(a, do.par=FALSE, caption=caption, degree1=c(1,2,4,5))
 grid:    vh wind humidity temp    ibh
        5760    5       64   62 2112.5
> attach(ozone1)
> a <- lm(log(doy) ~ I(vh*wind) + wind + I(humidity*temp) + log(ibh))
> plotmo(a, do.par=FALSE, degree1=c(1,2,4,5))
 grid:    vh wind humidity temp    ibh
        5760    5       64   62 2112.5
> detach(ozone1)
> 
> # commented out because "$" in names is not yet supported
> # a <- lm(log(ozone1$doy) ~ I(ozone1$vh*ozone1$wind) + log(ozone1$ibh))
> # plotmo(a)
> 
> set.seed(1)
> caption <- "test lm and glm a900..a902: damage~temp family=binomial data=orings"
> dopar(2,3,caption)
                              test lm and glm a900..a902: damage~temp family=binomial data=orings 
> library(faraway)
> data(orings)
> a900 <- lm(I(damage/6) ~ temp, data=orings)
> plotmo(a900, do.par=FALSE, caption=caption, col.response=2, nrug=-1,
+     main="lm(damage/6~temp)", smooth.col="indianred", trace=0)
> response <- cbind(orings$damage, 6-orings$damage)
> a901 <- glm(response ~ temp, family="binomial", data=orings)
> plotmo(a901, do.par=FALSE, col.response=2, nrug=-1,
+        main="glm(response~temp)", smooth.col="indianred", trace=2)
using the environment saved with the glm model: R_GlobalEnv
plotmo trace 2: plotmo(object=a901, smooth.col="indianred", nrug=-1,
                       do.par=FALSE, trace=2, col.response=2,
                       main="glm(response~temp)")
object$call is glm(formula=response~temp, family="binomial", data=orings)
--plotmo_x for glm object
object$x is NULL (and it has no colnames)
object$call is glm(formula=response~temp, family="binomial", data=orings)
formula(object) is response~temp
naked formula is the same
formula is valid, now looking for data for the model.frame
object$model is usable and has column names response temp
model.frame[,-1] is usable and has column name temp
plotmo_x returned[23,1]:
    temp
1     53
2     57
3     58
...   63
23    81

----Metadata: plotmo_predict with nresponse=NULL and newdata=NULL
plotmo_predict with NULL newdata (nrows=3), using plotmo_x to get the data
--plotmo_x for glm object
object$x is NULL (and it has no colnames)
object$call is glm(formula=response~temp, family="binomial", data=orings)
formula(object) is response~temp
naked formula is the same
formula is valid, now looking for data for the model.frame
object$model is usable and has column names response temp
model.frame[,-1] is usable and has column name temp
plotmo_x returned[23,1]:
    temp
1     53
2     57
3     58
...   63
23    81
will use the above data instead of newdata=NULL for predict.glm
stats::predict(glm.object, data.frame[3,1], type="response")
predict returned[3,1] with no column names:
         NA
1 0.5504788
2 0.3402166
3 0.2934757
predict after processing with nresponse=NULL is [3,1] with no column names:
         NA
1 0.5504788
2 0.3402166
3 0.2934757

----Metadata: plotmo_fitted with nresponse=NULL
stats::fitted(object=glm.object)
fitted(object) returned[23,1] with no column names:
             NA
1   0.550478817
2   0.340216592
3   0.293475686
... 0.123496147
23  0.002866088
fitted(object) after processing with nresponse=NULL is [23,1] with no column names:
             NA
1   0.550478817
2   0.340216592
3   0.293475686
... 0.123496147
23  0.002866088

----Metadata: plotmo_y with nresponse=NULL
--plotmo_y with nresponse=NULL for glm object
object$y is usable but without colnames so we will keep on searching
object$call is glm(formula=response~temp, family="binomial", data=orings)
formula(object) is response~temp
naked formula is the same
formula is valid, now looking for data for the model.frame
object$model is usable and has column names response temp
model.frame[,1] is usable and has column name response
the variable on the left side of the formula is a matrix or data.frame
the number of dimensions of each variable in y is 2 and y is [23,1] with colname response
replacing y with y[[1]]
y colnames were "response" and now "response[,1]" "response[,2]"
plotmo_y returned[23,2]:
    response[,1] response[,2]
1              5            1
2              1            5
3              1            5
...            1            5
23             0            6
plotmo_y after processing with nresponse=NULL is [23,2]:
    response[,1] response[,2]
1              5            1
2              1            5
3              1            5
...            1            5
23             0            6
converted nresponse=NA to nresponse=1
nresponse=1 (was NA) ncol(fitted) 1 ncol(predict) 1 ncol(y) 2

----Metadata: plotmo_y with nresponse=1
--plotmo_y with nresponse=1 for glm object
object$y is usable but without colnames so we will keep on searching
object$call is glm(formula=response~temp, family="binomial", data=orings)
formula(object) is response~temp
formula is valid, now looking for data for the model.frame
object$model is usable and has column names response temp
model.frame[,1] is usable and has column name response
the variable on the left side of the formula is a matrix or data.frame
the number of dimensions of each variable in y is 2 and y is [23,1] with colname response
replacing y with y[[1]]
y colnames were "response" and now "response[,1]" "response[,2]"
got model response from object$model
created column "response.fraction" from two column binomial response
plotmo_y returned[23,1]:
    response.fraction
1           0.8333333
2           0.1666667
3           0.1666667
...         0.1666667
23          0.0000000
plotmo_y after processing with nresponse=1 is [23,1]:
    response.fraction
1           0.8333333
2           0.1666667
3           0.1666667
...         0.1666667
23          0.0000000
got response name "response[,1]" from yfull
resp.levs is NULL

----Metadata: done

number of x values: temp 16

----plotmo_singles for glm object
singles: 1 temp 

----plotmo_pairs for glm object
formula(object) returned response~temp
formula.vars "temp"
term.labels "temp"
plotmo.pairs.from.term.labels
term.labels: "temp" "temp"
pred.names:  "temp"
considering temp
considering temp
no pairs

----Figuring out ylim
--get.ylim.by.dummy.plots
--plot.degree1(draw.plot=FALSE)
degree1 plot 1 temp
newdata[50,1]:
        temp
1   53.00000
2   53.57143
3   54.14286
... 54.71429
50  81.00000
stats::predict(glm.object, data.frame[50,1], type="response")
predict returned[50,1] with no column names:
             NA
1   0.550478817
2   0.519750569
3   0.488872165
... 0.458078452
50  0.002866088
predict after processing with nresponse=1 is [50,1]:
        predict
1   0.550478817
2   0.519750569
3   0.488872165
... 0.458078452
50  0.002866088
--done get.ylim.by.dummy.plots

ylim c(-0.09738, 0.8187)    clip TRUE

--plot.degree1(draw.plot=TRUE)
graphics::plot.default(x=c(53,53.57,54.1...), y=c(0.5505,0.5198...), type="n",
                       main="glm(response~temp)", xlab="", ylab="", xaxt="s",
                       yaxt="s", xlim=c(53,81), ylim=c(-0.0974,0.8187))
> a902 <- glm(cbind(damage, 6-damage)~temp, family="binomial", data=orings)
> plotmo(a902, do.par=FALSE, col.response=2, nrug=TRUE,
+        main="glm(cbind(damage,6-damage)~temp)", trace=0)
> termplot(a902, main="termplot")
> plotmo(a902, type="link", main="type=\"link\"", do.par=F)
> plotmo(a902, type="response", main="type=\"response\"", col.response=2, do.par=F)
> par(mfrow=c(1,1))
> 
> set.seed(1)
> caption <- "test glm(lot2~log(u),data=clotting,family=Gamma)"
> dopar(2,2,caption)
                              test glm(lot2~log(u),data=clotting,family=Gamma) 
> u = c(5,10,15,20,30,40,60,80,100)
> lota = c(118,58,42,35,27,25,21,19,18)
> clotting <- data.frame(u = u, lota = lota)
> a <- glm(lota ~ log(u), data=clotting, family=Gamma)
> plotmo(a, do.par=FALSE, caption=caption, col.response=3, clip=FALSE, nrug=-1)
> termplot(a)
> plotmo(a, type="link", caption=paste("type=\"link\"", caption))
> 
> if(length(grep("package:gam", search())))
+     detach("package:gam")
> library(mgcv)
Loading required package: nlme
This is mgcv 1.8-7. For overview type 'help("mgcv-package")'.
> set.seed(1)
> caption <- "test plot.gam, with mgcv::gam(y ~ s(x) + s(x,z)) with response and func (and extra image plot)"
> dopar(3,2,caption)
                              test plot.gam, with mgcv::gam(y ~ s(x) + s(x,z)) with response and func (and extra image plot) 
> par(mar = c(3, 5, 1.7, 0.5))    # more space for left and bottom axis
> test1 <- function(x,sx=0.3,sz=0.4)
+     (pi**sx*sz)*(1.2*exp(-(x[,1]-0.2)^2/sx^2-(x[,2]-0.3)^2/sz^2)+
+     0.8*exp(-(x[,1]-0.7)^2/sx^2-(x[,2]-0.8)^2/sz^2))
> n <- 100
> set.seed(1)
> x <- runif(n);
> z1 <- runif(n);
> y <- test1(cbind(x,z1)) + rnorm(n) * 0.1
> a <- gam(y ~ s(x) + s(x,z1))
> plotmo(a, do.par=FALSE, type2="contour", caption=caption, col.response=3, smooth.col="indianred",
+       func=test1, func.col="indianred", func.lwd=5, func.lty=2, smooth.lwd=3)
 grid:    x        z1
  0.4878107 0.5185988
> 
> plotmo(a, do.par=FALSE, degree1=F, degree2=1, type2="image", ylim=NA)
> plot(a, select=1)
> plot(a, select=2)
> plot(a, select=3)
> n<-400
> sig<-2
> set.seed(1)
> x0 <- runif(n, 0, 1)
> x1 <- runif(n, 0, 1)
> x2 <- runif(n, 0, 1)
> x3 <- runif(n, 0, 1)
> f0 <- function(x) 2 * sin(pi * x)
> f1 <- function(x) exp(2 * x)
> f2 <- function(x) 0.2*x^11*(10*(1-x))^6+10*(10*x)^3*(1-x)^10
> f <- f0(x0) + f1(x1) + f2(x2)
> e <- rnorm(n, 0, sig)
> y <- f + e
> test.func <- function(x) f0(x[,1]) + f1(x[,2]) + f2(x[,3])
> library(mgcv)
> caption <- "test mgcv::gam(y~s(x0,x1,k=12)+s(x2)+s(x3,k=20,fx=20)) (and extra persp plot)"
> dopar(3,3,caption)
                              test mgcv::gam(y~s(x0,x1,k=12)+s(x2)+s(x3,k=20,fx=20)) (and extra persp plot) 
> a <- gam(y~s(x0,x1,k=12)+s(x2)+s(x3,k=20,fx=20))
> plot(a, select=2)
> plot(a, select=3)
> plot(a, select=1)
> plotmo(a, do.par=FALSE, type2="contour", caption=caption, xlab=NULL, main="", func=test.func, ngrid2=10, drawlabels=FALSE)
 grid:    x0        x1        x2       x3
    0.474141 0.5151294 0.4460308 0.479208
> plotmo(a, do.par=FALSE, degree1=F, degree2=1, persp.the=-35)
> 
> set.seed(1)
> caption <- "test plot.gam, with mgcv::gam(doy~s(wind)+s(humidity,wind)+s(vh)+temp,data=ozone1)"
> dopar(3,3,caption)
                              test plot.gam, with mgcv::gam(doy~s(wind)+s(humidity,wind)+s(vh)+temp,data=ozone1) 
> a <- gam(doy ~ s(wind) + s(humidity,wind) + s(vh) + temp, data=ozone1)
> plotmo(a, do.par=FALSE, caption=caption, type2="contour", degree1=c("wind","vh"), swapxy=T, xlab=NULL, main="", clip=FALSE)
 grid:    temp wind humidity   vh
            62    5       64 5760
> plot(a, select=1)
> plot(a, select=3)
> plot(a, select=2)
> plot(a, select=4)
> 
> detach("package:mgcv")
> library(gam)
Loading required package: splines
Loading required package: foreach
Loaded gam 1.12

> caption <- "test gam:gam(Ozone^(1/3)~lo(Solar.R)+lo(Wind, Temp),data=airquality)"
> set.seed(1)
> dopar(3,2,caption)
                              test gam:gam(Ozone^(1/3)~lo(Solar.R)+lo(Wind, Temp),data=airquality) 
> data(airquality)
> airquality <- na.omit(airquality)   # plotmo doesn't know how to deal with NAs yet
> a <- gam(Ozone^(1/3) ~ lo(Solar.R) + lo(Wind, Temp), data = airquality)
> plotmo(a, do.par=FALSE, caption=caption, ylim=NA, col.response=3)
> # termplot gives fishy looking wind plot, plotmo looks ok
> # termplot(a) #TODO this fails with R2.5: dim(data) <- dim: attempt to set an attribute on NULL
> detach("package:gam")
> 
> library(mda)
Loading required package: class
Loaded mda 0.4-7

> caption <- "test mars and earth (expect not a close match)"
> dopar(6,3,caption)
                              test mars and earth (expect not a close match) 
> a <- mars( ozone1[, -1], ozone1[,1], degree=2)
> b <- earth(ozone1[, -1], ozone1[,1], degree=2)
> # this also tests trace=2 on a non formula model
> plotmo(a, do.par=FALSE, caption=caption, trace=2)
assuming the environment of the mars model is that of plotmo's caller: R_GlobalEnv
plotmo trace 2: plotmo(object=a, do.par=FALSE, caption=caption, trace=2)
object$call is mars(x=ozone1[, -1], y=ozone1[, 1], degree=2)
--plotmo_x for mars object
ignoring object$x for this mars object
object$call is mars(x=ozone1[, -1], y=ozone1[, 1], degree=2)
formula(object) did not return a formula
no formula in object$call
eval(object$call$x, R_GlobalEnv)
object$call$x is usable and has column names vh wind humidity temp ibh dpg ibt vis doy
plotmo_x returned[330,9]:
      vh wind humidity temp  ibh dpg ibt vis doy
1   5710    4       28   40 2693 -25  87 250  33
2   5700    3       37   45  590 -24 128 100  34
3   5760    3       51   54 1450  25 139  60  35
... 5720    4       69   35 1568  15 121  60  36
330 5550    4       85   39 5000   8  44 100 390

----Metadata: plotmo_predict with nresponse=NULL and newdata=NULL
plotmo_predict with NULL newdata (nrows=3), using plotmo_x to get the data
--plotmo_x for mars object
ignoring object$x for this mars object
object$call is mars(x=ozone1[, -1], y=ozone1[, 1], degree=2)
formula(object) did not return a formula
no formula in object$call
eval(object$call$x, R_GlobalEnv)
object$call$x is usable and has column names vh wind humidity temp ibh dpg ibt vis doy
plotmo_x returned[330,9]:
      vh wind humidity temp  ibh dpg ibt vis doy
1   5710    4       28   40 2693 -25  87 250  33
2   5700    3       37   45  590 -24 128 100  34
3   5760    3       51   54 1450  25 139  60  35
... 5720    4       69   35 1568  15 121  60  36
330 5550    4       85   39 5000   8  44 100 390
will use the above data instead of newdata=NULL for predict.mars
stats::predict(mars.object, data.frame[3,9], type="response")
predict returned[3,1] with no column names:
        NA
1 3.333568
2 1.865073
3 7.044289
predict after processing with nresponse=NULL is [3,1] with no column names:
        NA
1 3.333568
2 1.865073
3 7.044289

----Metadata: plotmo_fitted with nresponse=NULL
stats::fitted(object=mars.object)
fitted(object) returned[330,1] with no column names:
          NA
1   3.333568
2   1.865073
3   7.044289
... 6.925382
330 1.885331
fitted(object) after processing with nresponse=NULL is [330,1] with no column names:
          NA
1   3.333568
2   1.865073
3   7.044289
... 6.925382
330 1.885331

----Metadata: plotmo_y with nresponse=NULL
--plotmo_y with nresponse=NULL for mars object
object$y is NULL (and it has no colnames)
object$call is mars(x=ozone1[, -1], y=ozone1[, 1], degree=2)
formula(object) did not return a formula
no formula in object$call
eval(object$call$y, R_GlobalEnv)
object$call$y is usable but without colnames so we will keep on searching
names(call) is "" "x" "y" "degree"
the name of argument 2 is "y" so we will not process it with argn
object$y is NULL
call$y is usable but without colnames but we will use it anyway
plotmo_y returned[330,1] with no column names:
    NA
1    3
2    5
3    5
...  6
330  1
plotmo_y after processing with nresponse=NULL is [330,1] with no column names:
    NA
1    3
2    5
3    5
...  6
330  1
converted nresponse=NA to nresponse=1
nresponse=1 (was NA) ncol(fitted) 1 ncol(predict) 1 ncol(y) 1

----Metadata: plotmo_y with nresponse=1
--plotmo_y with nresponse=1 for mars object
object$y is NULL (and it has no colnames)
object$call is mars(x=ozone1[, -1], y=ozone1[, 1], degree=2)
formula(object) did not return a formula
no formula in object$call
eval(object$call$y, R_GlobalEnv)
object$call$y is usable but without colnames so we will keep on searching
names(call) is "" "x" "y" "degree"
the name of argument 2 is "y" so we will not process it with argn
object$y is NULL
call$y is usable but without colnames but we will use it anyway
got model response from object$call$y
plotmo_y returned[330,1] with no column names:
    NA
1    3
2    5
3    5
...  6
330  1
plotmo_y after processing with nresponse=1 is [330,1]:
    plotmo_y
1          3
2          5
3          5
...        6
330        1
response name is NULL
resp.levs is NULL

----Metadata: done

number of x values: vh 53 wind 11 humidity 65 temp 63 ibh 196 dpg 128 ibt 193...

----plotmo_singles for mars object
singles: 1 vh, 2 wind, 3 humidity, 4 temp, 5 ibh, 6 dpg, 7 ibt, 8 vis, 9 doy 

----plotmo_pairs for mars object
Error in formula.default(object) : invalid formula
formula(object) failed for "mars" object in plotmo.pairs.default
Error in terms.default(object) : no terms component nor attribute
terms(object) failed for "mars" object in plotmo.pairs.default
no pairs

----Figuring out ylim
--get.ylim.by.dummy.plots
--plot.degree1(draw.plot=FALSE)

 grid:    vh wind humidity temp    ibh dpg   ibt vis   doy
        5760    5       64   62 2112.5  24 167.5 120 205.5

degree1 plot 1 vh
newdata[50,9]:
          vh wind humidity temp    ibh dpg   ibt vis   doy
1   5320.000    5       64   62 2112.5  24 167.5 120 205.5
2   5332.857    5       64   62 2112.5  24 167.5 120 205.5
3   5345.714    5       64   62 2112.5  24 167.5 120 205.5
... 5358.571    5       64   62 2112.5  24 167.5 120 205.5
50  5950.000    5       64   62 2112.5  24 167.5 120 205.5
stats::predict(mars.object, data.frame[50,9], type="response")
predict returned[50,1] with no column names:
           NA
1    8.123619
2    8.303007
3    8.482395
...  8.661783
50  16.216014
predict after processing with nresponse=1 is [50,1]:
      predict
1    8.123619
2    8.303007
3    8.482395
...  8.661783
50  16.216014
Reducing trace level for subsequent degree1 plots
degree1 plot 2 wind
degree1 plot 3 humidity
degree1 plot 4 temp
degree1 plot 5 ibh
degree1 plot 6 dpg
degree1 plot 7 ibt
degree1 plot 8 vis
degree1 plot 9 doy
--done get.ylim.by.dummy.plots

ylim c(6.671, 20.41)    clip TRUE

--plot.degree1(draw.plot=TRUE)
graphics::plot.default(x=c(5320,5333,534...), y=c(8.124,8.303,8...), type="n",
                       main="1 vh", xlab="", ylab="", xaxt="s", yaxt="s",
                       xlim=c(5320,5950), ylim=c(6.671,20.42))
> plotmo(b, do.par=FALSE)
 grid:    vh wind humidity temp    ibh dpg   ibt vis   doy
        5760    5       64   62 2112.5  24 167.5 120 205.5
> 
> caption <- "test mars and mars.to.earth(mars) (expect no degree2 for mars)"
> dopar(6,3,caption)
                              test mars and mars.to.earth(mars) (expect no degree2 for mars) 
> a <- mars(ozone1[, -1], ozone1[,1], degree=2)
> b <- mars.to.earth(a)
Converted mars(x=ozone1[,-1], y=ozone1[,1], degree=2)

to earth(x=ozone1[,-1], y=ozone1[,1], degree=2)

> plotmo(a, do.par=FALSE, caption=caption, ylim=NA)
> plotmo(b, do.par=FALSE, ylim=NA)
> 
> # check fix for bug reported by Martin Maechler:
> # form <- Volume ~ .; a <- earth(form, data = trees); plotmo(a) fails
> 
> dopar(4,4, "test f <- O3 ~ .; a <- earth(f, data=ozone1)")
                              test f <- O3 ~ .; a <- earth(f, data=ozone1) 
> fa <- log(O3) ~ .
> a <- earth(fa, data=ozone1, degree=2)
> print(summary(a))
Call: earth(formula=fa, data=ozone1, degree=2)

                             coefficients
(Intercept)                    2.79412331
h(47-humidity)                -0.01328663
h(52-temp)                    -0.01753702
h(temp-52)                     0.02311792
h(1105-ibh)                   -0.00030601
h(13-dpg)                     -0.00523433
h(dpg-13)                     -0.00788042
h(194-ibt)                    -0.00459263
h(200-vis)                     0.00195292
h(96-doy)                     -0.01324138
h(doy-96)                     -0.00278616
h(wind-7) * h(200-vis)        -0.00153720
h(43-humidity) * h(52-temp)    0.00187488
h(humidity-67) * h(ibh-1105)  -0.00000914

Selected 14 of 21 terms, and 8 of 9 predictors
Termination condition: Reached nk 21
Importance: temp, ibt, doy, humidity, ibh, dpg, vis, wind, vh-unused
Number of terms at each degree of interaction: 1 10 3
GCV 0.1058972    RSS 28.2111    GRSq 0.8114829    RSq 0.8468883
> plot(a, do.par=FALSE)
> plotmo(a, do.par=FALSE, degree1=2:3, degree2=c(1,2), col.response = "pink", smooth.col="indianred")
 grid:    vh wind humidity temp    ibh dpg   ibt vis   doy
        5760    5       64   62 2112.5  24 167.5 120 205.5
> a <- lm(log(doy) ~ I(vh*wind) + I(humidity*temp) + log(ibh), data=ozone1)
> plotmo(a, do.par=FALSE, degree1=1:2)
 grid:    vh wind humidity temp    ibh
        5760    5       64   62 2112.5
> fa <- log(doy) ~ I(vh*wind) + I(humidity*temp) + log(ibh)
> a <- lm(fa, data=ozone1)
> plotmo(a, do.par=FALSE, degree1=1:2)
 grid:    vh wind humidity temp    ibh
        5760    5       64   62 2112.5
> 
> # test inverse.func and func
> 
> caption <- "test inverse.func=exp"
> a <- lm(log(Volume) ~ Girth + Height + I(Girth*Height), data=trees)
> my.func <- function(x) -60 + 5 * x[,1] + x[,2] / 3
> plotmo(a, caption=caption, inverse.func = exp, col.response = "pink", func=my.func, func.col="gray", ngrid1=1000, type2="p", smooth.col="indianred")
 grid:    Girth Height
           12.9     76
> 
> # se testing
> 
> caption = "level=.95, lm(doy~., data=ozone1) versus termplot"
> dopar(6,3,caption)
                              level=.95, lm(doy~., data=ozone1) versus termplot 
> a <- lm(doy~., data=ozone1)
> plotmo(a, level=.95, do.par=FALSE, caption=caption)
 grid:    O3   vh wind humidity temp    ibh dpg   ibt vis
          10 5760    5       64   62 2112.5  24 167.5 120
> termplot(a, se=2)
> 
> caption <- "test different se options, level=.95, lm(log(doy)~vh+wind+log(humidity),data=ozone1)"
> dopar(4,3,caption)
                              test different se options, level=.95, lm(log(doy)~vh+wind+log(humidity),data=ozone1) 
> a <- lm(log(doy) ~ vh + wind + log(humidity), data=ozone1)
> plotmo(a, do.par=FALSE, caption=caption, ylim=NA, level=.95)
> plotmo(a, do.par=FALSE, caption=caption, ylim=NA, level=.95, level.shade="pink", level.shade2=3)
> plotmo(a, do.par=FALSE, caption=caption, ylim=NA, level=.95, level.shade=3)
> plotmo(a, do.par=FALSE, caption=caption, ylim=NULL, level=.95, level.shade=3)
 grid:    vh wind humidity
        5760    5       64
> 
> caption <- "test level=.95, lm(log(doy)~vh+wind+log(humidity),data=ozone1)"
> dopar(2,3,caption)
                              test level=.95, lm(log(doy)~vh+wind+log(humidity),data=ozone1) 
> a <- lm(log(doy) ~ vh + wind + log(humidity), data=ozone1)
> plotmo(a, do.par=FALSE, caption=caption, ylim=NA, level=.95)
> termplot(a, se=2)
> 
> caption <- "test level=.95 and inverse.func, lm(log(doy)~vh+wind+log(humidity),data=ozone1)"
> dopar(3,3,caption)
                              test level=.95 and inverse.func, lm(log(doy)~vh+wind+log(humidity),data=ozone1) 
> a <- lm(log(doy) ~ vh + wind + log(humidity), data=ozone1)
> plotmo(a, do.par=FALSE, caption=caption, ylim=NA, level=.95)
> plotmo(a, do.par=FALSE, caption=caption, ylim=NULL, level=.95, inverse.func=exp)
 grid:    vh wind humidity
        5760    5       64
> termplot(a, se=2)
> 
> caption <- "test level=.95, glm(lot2~log(u),data=clotting,family=Gamma)"
> set.seed(1)
> dopar(2,2,caption)
                              test level=.95, glm(lot2~log(u),data=clotting,family=Gamma) 
> u = c(5,10,15,20,30,40,60,80,100)
> lota = c(118,58,42,35,27,25,21,19,18)
> clotting <- data.frame(u = u, lota = lota)
> a <- glm(lota ~ log(u), data=clotting, family=Gamma)
> plotmo(a, do.par=FALSE, caption=caption, col.response=4, pt.pch=7, clip=FALSE, nrug=-1, level=.95, smooth.col="indianred")
Warning: the level argument may not work correctly on glm objects built with weights
> termplot(a, se=2)
> 
> if(length(grep("package:gam", search())))
+     detach("package:gam")
> library(mgcv)
This is mgcv 1.8-7. For overview type 'help("mgcv-package")'.
> set.seed(1)
> caption <- "test level=.95, plot.gam, with mgcv::gam(y ~ s(x) + s(x,z1)) with response and func (and extra image plot)"
> dopar(3,2,caption)
                              test level=.95, plot.gam, with mgcv::gam(y ~ s(x) + s(x,z1)) with response and func (and extra image plot) 
> par(mar = c(3, 5, 1.7, 0.5))    # more space for left and bottom axis
> test1 <- function(x,sx=0.3,sz=0.4)
+     (pi**sx*sz)*(1.2*exp(-(x[,1]-0.2)^2/sx^2-(x[,2]-0.3)^2/sz^2)+
+     0.8*exp(-(x[,1]-0.7)^2/sx^2-(x[,2]-0.8)^2/sz^2))
> n <- 100
> set.seed(1)
> x <- runif(n);
> z1 <- runif(n);
> y <- test1(cbind(x,z1)) + rnorm(n) * 0.1
> a <- gam(y ~ s(x) + s(x,z1))
> plotmo(a, do.par=FALSE, type2="contour", caption=caption, col.response=3, func=test1, func.col="magenta", level=.95)
 grid:    x        z1
  0.4878107 0.5185988
> plotmo(a, do.par=FALSE, degree1=F, degree2=1, type2="image", image.col=topo.colors(10),
+         ylim=NA, level=.95, main="topo.colors")
> plot(a, select=1)
> plot(a, select=2)
> plot(a, select=3)
> 
> # TODO Following commented out because it causes:
> #      Error: gam objects in the "gam" package do not support confidence intervals on new data
> # detach("package:mgcv")
> # library(gam)
> # set.seed(1)
> # caption <- "test level=.95, gam:gam(Ozone^(1/3)~lo(Solar.R)+lo(Wind, Temp),data=airquality)"
> # dopar(3,2,caption)
> # data(airquality)
> # airquality <- na.omit(airquality)   # plotmo doesn't know how to deal with NAs yet
> # a <- gam(Ozone^(1/3) ~ lo(Solar.R) + lo(Wind, Temp), data = airquality)
> # plotmo(a, do.par=FALSE, caption=caption, ylim=NA, col.response=3, level=.95)
> # # termplot(a)  #TODO this fails with R2.5: dim(data) <- dim: attempt to set an attribute on NULL
> # detach("package:gam")
> 
> # test factors by changing wind to a factor
> 
> ozone2 <- ozone1
> ozone2[,"wind"] <- factor(ozone2[,"wind"], labels=c(
+     "wind0", "wind2", "wind3", "wind4", "wind5", "wind6",
+     "wind7", "wind8", "wind9", "wind10", "wind11"))
> 
> # commented out because factors are not yet supported by plotmo.earth
> # caption <- "test wind=factor, earth(O3 ~ ., data=ozone2)"
> # a <- earth(doy ~ ., data=ozone2)
> # set.seed(1)
> # dopar(4,3,caption)
> # plotmo(a, col.response="gray", level=.95, nrug=-1, do.par=FALSE, caption=caption)
> # termplot(a)
> 
> caption <- "test wind=factor, lm(doy ~ vh + wind + I(humidity*temp) + log(ibh), data=ozone2)"
> a <- lm(doy ~ vh + wind + I(humidity*temp) + log(ibh), data=ozone2)
> set.seed(1)
> dopar(4,3,caption)
                              test wind=factor, lm(doy ~ vh + wind + I(humidity*temp) + log(ibh), data=ozone2) 
> plotmo(a, col.response="gray", level=.95, nrug=-1, do.par=FALSE, caption=caption, smooth.col="indianred")
 grid:    vh  wind humidity temp    ibh
        5760 wind0       64   62 2112.5
> termplot(a, se=2)
> 
> caption <- "test level options"
> dopar(2,2,caption)
                              test level options 
> plotmo(a, do.par=FALSE, degree1=2, degree2=FALSE, level=.95, level.shade=0, caption=caption)
 grid:    vh  wind humidity temp    ibh
        5760 wind0       64   62 2112.5
> plotmo(a, do.par=FALSE, degree1=2, degree2=FALSE, level=.95, level.shade="orange")
 grid:    vh  wind humidity temp    ibh
        5760 wind0       64   62 2112.5
> plotmo(a, do.par=FALSE, degree1=2, degree2=FALSE, level=.95, level.shade2=0)
 grid:    vh  wind humidity temp    ibh
        5760 wind0       64   62 2112.5
> 
> caption <- "test wind=factor, glm(y ~ i + j, family=poisson())"
> y <- c(18,17,15,20,10,20,25,13,12)
> i <- gl(3,1,9)
> j <- gl(3,3)
> a <- glm(y ~ i + j, family=poisson())
> set.seed(1)
> dopar(2,2,caption)
                              test wind=factor, glm(y ~ i + j, family=poisson()) 
> plotmo(a, do.par=F, level=.95, nrug=-1, caption=caption)
 grid:    i j
          1 1
Warning: the level argument may not work correctly on glm objects built with weights
Warning: the level argument may not work correctly on glm objects built with weights
> termplot(a, se=1, rug=T)
> 
> if(length(grep("package:gam", search())))
+    detach("package:gam")
> caption <- "test wind=factor, gam(doy ~ vh + wind + s(humidity) + s(vh) + temp, data=ozone2)"
> library(mgcv)
> a <- gam(doy ~ vh + wind + s(humidity) + s(vh) + temp, data=ozone2)
> plotmo(a, level=.95, caption=caption)
 grid:    vh  wind temp humidity
        5760 wind0   62       64
> caption <- "test wind=factor, clip=TRUE, gam(doy ~ vh + wind + s(humidity) + s(vh) + temp, data=ozone2)"
> plotmo(a, level=.95, caption=caption, clip=FALSE)
 grid:    vh  wind temp humidity
        5760 wind0   62       64
> # termplot doesn't work here so code commented out
> # dopar(3,3,caption)
> # plotmo(a, do.par=FALSE)
> # termplot(a)
> 
> # test lda and qda, and also col.response, pt.pch, and jitter
> library(MASS)
> etitanic2 <- etitanic
> etitanic2$pclass <- as.numeric(etitanic$pclass)
> etitanic2$sex <- as.numeric(etitanic$sex)
> etitanic2$sibsp <- NULL
> etitanic2$parch <- NULL
> lda.model <- lda(survived ~ ., data=etitanic2)
> set.seed(7)
> plotmo(lda.model, caption="lda", clip=F,
+        col.response=as.numeric(etitanic2$survived)+2, type="posterior", nresponse=1, smooth.col="indianred",
+        all2=TRUE, type2="image")
 grid:    pclass sex age
               2   2  28
> set.seed(8)
> plotmo(lda.model, caption="lda with no jitter", clip=F,
+        col.response=as.numeric(etitanic2$survived)+2, type="posterior", nresponse=1,
+        all2=TRUE, type2="image", jitter=0)
 grid:    pclass sex age
               2   2  28
> qda.model <- qda(survived ~ ., data=etitanic2)
> set.seed(9)
> plotmo(qda.model, caption="qda", clip=F,
+        col.response=as.numeric(etitanic2$survived)+2, type="post", nresponse=2, smooth.col="indianred",
+        all2=TRUE, type2="image", jitter.resp=.6, pch.resp=20)
 grid:    pclass sex age
               2   2  28
> 
> # test plotmo.y from the 2nd argument of the model function (non-formula interface)
> lcush <- data.frame(Type=as.numeric(Cushings$Type), log(Cushings[,1:2]))[1:21,]
> a <- qda(lcush[,2:3], lcush[,1])
> plotmo(a, type="class", all2=TRUE,
+        caption= "plotmo.y from 2nd argument of call (qda)",
+        type2="contour", ngrid2=100, nlevels=2, drawlabels=FALSE,
+        col.response=as.numeric(lcush$Type)+1,
+        pt.pch=as.character(lcush$Type))
 grid:    Tetrahydrocortisone Pregnanetriol
                      2.04122     0.1823216
> 
> # # example from MASS (works, but removed because unnecessary test)
> # predplot <- function(object, main="", len = 100, ...)
> # {
> #     plot(Cushings[,1], Cushings[,2], log="xy", type="n",
> #          xlab = "Tetrahydrocortisone", ylab = "Pregnanetriol", main = main)
> #     for(il in 1:4) {
> #         set <- Cushings$Type==levels(Cushings$Type)[il]
> #         text(Cushings[set, 1], Cushings[set, 2],
> #              labels=as.character(Cushings$Type[set]), col = 2 + il) }
> #     xp <- seq(0.6, 4.0, length=len)
> #     yp <- seq(-3.25, 2.45, length=len)
> #     cushT <- expand.grid(Tetrahydrocortisone = xp,
> #                          Pregnanetriol = yp)
> #     Z <- predict(object, cushT, ...); zp <- as.numeric(Z$class)
> #     zp <- Z$post[,3] - pmax(Z$post[,2], Z$post[,1])
> #     contour(exp(xp), exp(yp), matrix(zp, len),
> #             add = TRUE, levels = 0, labex = 0)
> #     zp <- Z$post[,1] - pmax(Z$post[,2], Z$post[,3])
> #     contour(exp(xp), exp(yp), matrix(zp, len),
> #             add = TRUE, levels = 0, labex = 0)
> #     invisible()
> # }
> # par(mfrow=c(2,2))
> # cush <- log(as.matrix(Cushings[, -3]))
> # tp <- Cushings$Type[1:21, drop = TRUE]
> # set.seed(203)
> # cush.data <- data.frame(tp, cush[1:21,])
> # a <- qda(tp~., data=cush.data)
> # predplot(a, "QDA example from MASS")
> # plotmo(a, type="class", all2=TRUE, type2="contour", degree1=NA, do.par=FALSE,
> #        col.response=as.numeric(cush.data$tp)+1)
> # plotmo(a, type="class", all2=TRUE, type2="contour", degree1=NA, do.par=FALSE,
> #        col.response=as.numeric(cush.data$tp)+1, drawlabels=F, nlevels=2)
> # plotmo(a, type="class", all2=TRUE, type2="contour", degree1=NA, do.par=FALSE,
> #        col.response=as.numeric(cush.data$tp)+1, drawlabels=F, nlevels=2, ngrid2=100)
> # par(mfrow=c(1,1))
> 
> library(rpart.plot)
Loading required package: rpart

Attaching package: 'rpart'

The following object is masked from 'package:faraway':

    solder

> data(kyphosis)
> # kyphosis data, earth model
> a <- earth(Kyphosis ~ ., data=kyphosis, degree=2, glm=list(family=binomial))
> par(mfrow=c(3, 3))
> old.mar <- par(mar=c(3, 3, 2, .5))  # small margins to pack figs in
> set.seed(9) # for jitter
> plotmo(a, do.par=F, type2="image",
+        col.response=ifelse(kyphosis$Kyphosis=="present", "red", "lightblue"),
+        clip=F)
 grid:    Age Number Start
           87      4    13
> plotmo(a, do.par=F, clip=F, degree1=0)
> par(mar=old.mar)
> 
> # kyphosis data, rpart models (also test ngrid2)
> fit1 <- rpart(Kyphosis ~ ., data=kyphosis)
> par(mfrow=c(3, 3))
> old.par <- par(mar=c(.5, 0.5, 2, .5), mgp = c(1.6, 0.6, 0))  # b l t r small margins to pack figs in
> prp(fit1, main="rpart kyphosis\nno prior")
> plotmo(fit1, degree1=NA, do.par=F, main="", persp.theta=220, nresponse=2)
> par(mar=c(4, 4, 2, .5))
> plotmo(fit1, nresp=2, degree1=FALSE, do.par=F, main="", type2="image", # test default type="prob"
+        col.response=ifelse(kyphosis$Kyphosis=="present", "red", "lightblue"),
+        pt.pch=ifelse(kyphosis$Kyphosis=="present", "p", "a"),
+        image.col=gray(10:4/10), ngrid2=30)
> par(mar=c(.5, 0.5, 2, .5))  # b l t r small margins to pack figs in
> plotmo(fit1, type="class", degree1=NA, do.par=F, main="type=\"class\"")
> # with type="prob" and response has two columns,
> # nresponse should automatically default to column 2
> plotmo(fit1, type="prob", degree1=0, do.par=F, main="type=\"prob\"",
+        clip=F, ngrid2=50, persp.border=NA, trace=1)
stats::predict(rpart.object, data.frame[3,3], type="prob")
stats::fitted(object=rpart.object)
fitted() was unsuccessful, will use predict()
set nresponse=2
got model response from model.frame(Kyphosis~Age+Numb..., data=call$data, na.action="na.pass")
> plotmo(fit1, type="prob", nresp=2, degree1=NA, do.par=F, main="", type2="image",
+        col.response=ifelse(kyphosis$Kyphosis=="present", "red", "lightblue"),
+        pt.pch=20, image.col=gray(10:4/10), ngrid2=5)
> # better rpart model with prior
> fit2 <- rpart(Kyphosis ~ ., data=kyphosis, parms=list(prior=c(.65,.35)))
> prp(fit2, main="rpart kyphosis\nwith prior, better model")
> plotmo(fit2, type="v", degree1=NA, do.par=F, main="", persp.theta=220, ngrid2=10)
> par(mar=c(4, 4, 2, .5))
> plotmo(fit2, type="v", degree1=NA, do.par=F, main="", type2="image",
+        col.response=ifelse(kyphosis$Kyphosis=="present", "red", "lightblue"),
+        pt.pch=20, image.col=gray(10:4/10), ngrid2=100)
> par(mar=old.par$mar, mgp=old.par$mgp)
> 
> plotmo(fit1, type="prob", nresponse=1, persp.border=NA, persp.col="pink", all1=TRUE, all2=TRUE,
+        caption="plotmo rpart fit1, all1=TRUE, all2=TRUE")
 grid:    Age Number Start
           87      4    13
> expect.err(try(plotmo(fit1, type="none.such1")))
Error : predict.rpart does not support type="none.such1"
Got error as expected
> 
> # rpart model with ozone data
> data(ozone1)
> par(mfrow=c(4,4))
> old.par <- par(mar=c(.5, 0.5, 2, .5), cex=.6, mgp = c(1.6, 0.6, 0))  # b l t r small margins to pack figs in
> a1 <- rpart(O3~temp+humidity, data=ozone1)
> prp(a1, main="rpart model with ozone data\n(temp and humidity only)\n")
> plotmo(a1, do.par=F, degree1=0, main="rpart", persp.ticktype="detail", persp.nticks=2)
> expect.err(try(plotmo(a1, type="class")))
Error : predict.rpart does not support type="class" (for "anova" rpart objects)
Got error as expected
> # compare to a linear and earth model
> a3 <- lm(O3~temp+humidity, data=ozone1)
> plotmo(a3, do.par=F, clip=F, main="lm", degree1=0, all2=TRUE, persp.ticktype="detail", persp.nticks=2)
> expect.err(try(plotmo(a3, type="none.such2")))

stats::predict(lm.object, NULL, type="none.such2")

Error in match.arg(type) : 'arg' should be one of "response", "terms"
Got error as expected
> a <- earth(O3~temp+humidity, data=ozone1, degree=2)
> plotmo(a, do.par=F, clip=F, main="earth", degree1=NA, persp.ticktype="detail", persp.nticks=2)
> expect.err(try(plotmo(a, type="none.such3")))

stats::predict(earth.object, NULL, type="none.such3")

Error : type="none.such3" is not allowed
Choose one of "link" "response" "earth" "class" "terms"
Got error as expected
> expect.err(try(plotmo(a, type=c("abc", "def"))))
Error : type has more than one element
       type = c("abc" "def")
Got error as expected
> 
> # detailed rpart model
> par(mfrow=c(3,3))
> a1 <- rpart(O3~., data=ozone1)
> prp(a1, cex=.9, main="rpart model with full ozone data")
> plotmo(a1, type="vector", do.par=F, degree1=NA, persp.ticktype="detail",
+        persp.nticks=3, degree2=2:3)
> par(mar=old.par$mar, cex=old.par$cex, mgp=old.par$mgp)
> 
> plotmo(a1, persp.border=NA, all1=TRUE, all2=TRUE,
+        caption="plotmo rpart a1, all1=TRUE, all2=TRUE")
 grid:    vh wind humidity temp    ibh dpg   ibt vis   doy
        5760    5       64   62 2112.5  24 167.5 120 205.5
> 
> library(tree)
> tree1 <- tree(O3~., data=ozone1)
> plotmo(tree1)
 grid:    vh wind humidity temp    ibh dpg   ibt vis   doy
        5760    5       64   62 2112.5  24 167.5 120 205.5
> plotres(tree1)
> 
> # test xflip and yflip
> 
> par(mfrow=c(4, 4))
> par(mgp = c(1.6, 0.6, 0))
> par(mar=c(4, 4, 2, .5))
> 
> flip.test1 <- rpart(Kyphosis ~ ., data=kyphosis)
> plotmo(flip.test1, type="prob", nresp=2, degree1=NA, do.par=F, main="", type2="image",
+        col.response=ifelse(kyphosis$Kyphosis=="present", "red", "lightblue"),
+        pt.pch=20, image.col=gray(10:4/10))
> plotmo(flip.test1, type="prob", nresp=2, degree1=NA, do.par=F, main="xflip", type2="image",
+        col.response=ifelse(kyphosis$Kyphosis=="present", "red", "lightblue"),
+        pt.pch=20, image.col=gray(10:4/10),
+        xflip=T)
> plotmo(flip.test1, type="prob", nresp=2, degree1=NA, do.par=F, main="yflip", type2="image",
+        col.response=ifelse(kyphosis$Kyphosis=="present", "red", "lightblue"),
+        pt.pch=20, image.col=gray(10:4/10),
+        yflip=T)
> plotmo(flip.test1, type="prob", nresp=2, degree1=NA, do.par=F, main="xflip and yflip", type2="image",
+        col.response=ifelse(kyphosis$Kyphosis=="present", "red", "lightblue"),
+        pt.pch=20, image.col=gray(10:4/10),
+        xflip=T, yflip=T)
> 
> flip.test2 <- earth(O3~., data=ozone1, degree=2)
> plotmo(flip.test2, degree1=NA, degree2=2, do.par=F, main="", type2="cont")
> plotmo(flip.test2, degree1=NA, degree2=2, do.par=F, main="xflip", type2="cont",
+        xflip=T)
> plotmo(flip.test2, degree1=NA, degree2=2, do.par=F, main="yflip", type2="cont",
+        yflip=T)
> plotmo(flip.test2, degree1=NA, degree2=2, do.par=F, main="xflip and yflip", type2="cont",
+        xflip=T, yflip=T)
> 
> cat("Expect warnings: ignoring xflip=TRUE for persp plot\n")
Expect warnings: ignoring xflip=TRUE for persp plot
> plotmo(flip.test2, degree1=NA, degree2=2, do.par=F, main="xflip and yflip", type2="persp",
+        xflip=T, yflip=T)
Warning: ignoring xflip=TRUE for persp plot
Warning: ignoring yflip=TRUE for persp plot
> 
> library(randomForest)
randomForest 4.6-10
Type rfNews() to see new features/changes/bug fixes.
> data(ozone1)
> set.seed(2015)
> rf <- randomForest(age~., data=etitanic, ntree=100)
> plotmo(rf, trace=1)
stats::predict(randomForest.formula.object, data.frame[3,5], type="response")
stats::fitted(object=randomForest.formula.object)
fitted() was unsuccessful, will use predict()
got model response from model.frame(age~pclass+surviv..., data=call$data, na.action="na.fail")

 grid:    pclass survived    sex sibsp parch
             1st        0 female     0     0

> plotres(rf, trace=1)
stats::residuals(object=randomForest.formula.object, type="response")
residuals() was unsuccessful
stats::predict(randomForest.formula.object, data.frame[3,5], type="response")
stats::fitted(object=randomForest.formula.object)
fitted() was unsuccessful, will use predict()
got model response from model.frame(age~pclass+surviv..., data=call$data, na.action="na.fail")
graphics::plot(randomForest.formula.object, main="Error vs Number of Trees")

training rsq 0.30
> set.seed(3)
> a <- randomForest(O3~., data=ozone1, ntree=20)
> plotmo(a, caption="randomForest ozone1")
 grid:    vh wind humidity temp    ibh dpg   ibt vis   doy
        5760    5       64   62 2112.5  24 167.5 120 205.5
> plotres(a)
> set.seed(4)
> a <- randomForest(Kyphosis ~ ., data=kyphosis, ntree=5, mtry=2)
> plotmo(a, type="prob", nresponse="pre", caption="randomForest kyphosis", ndiscrete=10)
 grid:    Age Number Start
           87      4    13
> # TODO residuals are in range 0 to 1
> plotres(a, type="prob", nresponse="pre", caption="plotres randomForest kyphosis")

plotmo_y[81,1]:
    Kyphosis
1     absent
2     absent
3    present
...   absent
81    absent
  Kyphosis is a factor with levels: absent present

> 
> # gbm
> library(gbm)
Loading required package: survival

Attaching package: 'survival'

The following object is masked from 'package:faraway':

    rats

Loading required package: lattice

Attaching package: 'lattice'

The following object is masked from 'package:faraway':

    melanoma

Loading required package: parallel
Loaded gbm 2.1.1
> library(rpart.plot) # for ptitanic, want data with NAs for testing
> data(ptitanic)
> ptit <- ptitanic[c(1:10,400:410,600:610),] # small data for fast test
> ptit <- ptitanic
> ptit$survived <- ptit$survived == "survived"
> temp <- ptit$pclass # put pclass at the end so can check ordering of importances
> ptit$pclass <- NULL
> ptit$pclass <- factor(as.numeric(temp), labels=c("first", "second", "third"))
> set.seed(1010)
> gbm.model <- gbm(survived~., data=ptit, train.frac=.95, verbose=TRUE,
+                  n.trees=30, shrinkage=.1) # small number of trees for fast test
Distribution not specified, assuming bernoulli ...
Iter   TrainDeviance   ValidDeviance   StepSize   Improve
     1        1.2866          1.1075     0.1000    0.0267
     2        1.2462          1.0707     0.1000    0.0211
     3        1.2135          1.0380     0.1000    0.0173
     4        1.1838          1.0051     0.1000    0.0136
     5        1.1615          0.9809     0.1000    0.0113
     6        1.1451          0.9631     0.1000    0.0091
     7        1.1278          0.9437     0.1000    0.0076
     8        1.1135          0.9229     0.1000    0.0059
     9        1.1010          0.9032     0.1000    0.0061
    10        1.0903          0.8884     0.1000    0.0048
    20        1.0179          0.7965     0.1000    0.0020
    30        0.9866          0.7623     0.1000    0.0007

> 
> par(mfrow=c(4,4))
> par(mar=c(3.5, 3, 2, 0.5))  # small margins and text to pack figs in
> par(mgp=c(1.5, .5, 0))      # flatten axis elements
> plotmo(gbm.model, persp.ticktype="d", persp.nticks=2, do.par=F,
+        degree1=0, degree2=3, main="gbm model", caption="gbm models")
> plotmo(gbm.model, type2="im", do.par=F,
+        col.response=ptit$survived+2, pt.pch=20, pt.cex=.5)
 grid:    sex age sibsp parch pclass
       female  28     0     0  first
> print(summary(gbm.model))   # will also plot
          var   rel.inf
sex       sex 76.528849
pclass pclass 18.525225
age       age  3.353178
sibsp   sibsp  1.592748
parch   parch  0.000000
> plotres(gbm.model, col=ptit$survived+2, do.par=FALSE)
> par(mfrow=c(1,1))
> 
> ozplus <- ozone1
> # add more variables so we can test all1 and all2
> ozplus$ltemp <- log(ozplus$temp)
> ozplus$lhum <- log(ozplus$humidity)
> ozplus$ltemphum <- log(ozplus$temp) + log(ozplus$humidity)
> ozplus$ibttemp <- ozplus$ibt * ozplus$temp
> ozplus <- data.frame(scale(ozplus))
> set.seed(2015)
> gbm.ozplus <- gbm(O3~., data=ozplus, train.frac=.9,
+                n.trees=100, cv.fold=2, shrinkage=.1, interact=3)
Distribution not specified, assuming gaussian ...
> # note that we get different RSquareds printed in the trace here
> plotres(gbm.ozplus, trace=1, SHOWCALL=TRUE)
stats::residuals(object=gbm.object, type="response")
residuals() was unsuccessful
stats::predict(gbm.object, data.frame[3,13], type="response", n.trees=100)
stats::fitted(object=gbm.object)
fitted() was unsuccessful, will use predict()
plot.gbmx(gbm.object, n.trees=100)

training rsq 0.89
> plotres(gbm.ozplus, predict.n.trees=42, trace=1, SHOWCALL=TRUE)
stats::residuals(object=gbm.object, type="response")
residuals() was unsuccessful
stats::predict(gbm.object, data.frame[3,13], type="response", n.trees=42)
stats::fitted(object=gbm.object)
fitted() was unsuccessful, will use predict()
plot.gbmx(gbm.object, n.trees=42)

training rsq 0.83
> plotmo(gbm.ozplus, trace=-1, SHOWCALL=TRUE)
> plotmo(gbm.ozplus, trace=-1, all1=TRUE, SHOWCALL=TRUE)
> plotmo(gbm.ozplus, trace=-1, all2=TRUE, SHOWCALL=TRUE)
Warning: too many predictors to plot all pairs,
         so plotting degree2 plots for just the first 7 predictors
> 
> library(caret)
Loading required package: ggplot2

Attaching package: 'caret'

The following object is masked from 'package:survival':

    cluster

> set.seed(2015)
> caret.earth.mod <- train(O3~., data=ozone1, method="earth",
+                          tuneGrid=data.frame(degree=2, nprune=10))
> # TODO pairs are not plotted
> plotmo(caret.earth.mod, type="raw", trace=1, SHOWCALL=TRUE)
stats::predict(train.object, data.frame[3,9], type="raw")
stats::fitted(object=train.object)
got model response from model.frame(O3~vh+wind+humidi..., data=call$data, na.action="na.fail")

 grid:    vh wind humidity temp    ibh dpg   ibt vis   doy
        5760    5       64   62 2112.5  24 167.5 120 205.5

> # but the pairs are plotted here
> plotmo(caret.earth.mod$finalModel, trace=1, SHOWCALL=TRUE)
stats::predict(earth.object, NULL, type="response")
stats::fitted(object=earth.object)
got model response from object$y

 grid:    vh wind humidity temp    ibh dpg   ibt vis   doy
        5760    5       64   62 2112.5  24 167.5 120 205.5

> plotres(caret.earth.mod, type="raw", trace=1, SHOWCALL=TRUE)
stats::residuals(object=train.object, type="raw")
residuals() was unsuccessful
stats::predict(train.object, data.frame[3,9], type="raw")
stats::fitted(object=train.object)
got model response from model.frame(O3~vh+wind+humidi..., data=call$data, na.action="na.fail")

training rsq 0.81
> 
> set.seed(2015)
> bag <- bagEarth(O3~., data=ozone1, degree=2, B=3)
> print(bag$fit)
$Resample1
Selected 15 of 20 terms, and 8 of 9 predictors
Termination condition: Reached nk 21
Importance: temp, humidity, ibt, doy, dpg, vh, ibh, vis, wind-unused
Number of terms at each degree of interaction: 1 9 5
GCV 10.62368    RSS 2782.633    GRSq 0.8284277    RSq 0.8629907

$Resample2
Selected 17 of 21 terms, and 8 of 9 predictors
Termination condition: Reached nk 21
Importance: temp, humidity, dpg, doy, vis, ibt, ibh, vh, wind-unused
Number of terms at each degree of interaction: 1 8 8
GCV 13.77306    RSS 3485.877    GRSq 0.7983071    RSq 0.8443696

$Resample3
Selected 15 of 21 terms, and 7 of 9 predictors
Termination condition: Reached nk 21
Importance: temp, humidity, dpg, doy, vh, vis, ibh, wind-unused, ...
Number of terms at each degree of interaction: 1 8 6
GCV 13.71664    RSS 3592.762    GRSq 0.7669974    RSq 0.8139355

> # pairs are plotted correctly (I think)
> plotmo(bag, type="response", trace=1, SHOWCALL=TRUE)
stats::predict(bagEarth.object, data.frame[3,9], type="response")
stats::fitted(object=bagEarth.object)
fitted() was unsuccessful, will use predict()
got model response from model.frame(O3~., data=call$data, na.action="na.fail")

 grid:    vh wind humidity temp    ibh dpg   ibt vis   doy
        5760    5       64   62 2112.5  24 167.5 120 205.5

> 
> set.seed(2015)
> a.bag1 <- bagEarth(trees[,-3], trees[,3], degree=2, B = 3)
> plotres(a.bag1, trace=1, SHOWCALL=TRUE)
stats::residuals(object=bagEarth.object, type="response")
residuals() was unsuccessful
stats::predict(bagEarth.object, data.frame[3,2], type="response")
stats::fitted(object=bagEarth.object)
fitted() was unsuccessful, will use predict()
got model response from object$call$y

training rsq 0.98
> plotmo(a.bag1, trace=1, SHOWCALL=TRUE, all2=TRUE, caption="bagEarth, trees")
stats::predict(bagEarth.object, data.frame[3,2], type="response")
stats::fitted(object=bagEarth.object)
fitted() was unsuccessful, will use predict()
got model response from object$call$y

 grid:    Girth Height
           12.9     76

> 
> # TODO following doesn't work properly, factors are plotted as continuous?
> a.bag3 <- bagEarth(survived~., data=etitanic, degree=2, B=3)
> plotmo(a.bag3, clip=F, caption="bagEarth, etitanic", trace=1, SHOWCALL=TRUE)
stats::predict(bagEarth.object, data.frame[3,7], type="response")
stats::fitted(object=bagEarth.object)
fitted() was unsuccessful, will use predict()
got model response from model.frame(survived~., data=call$data, na.action="na.fail")

 grid:    pclass1st pclass2nd pclass3rd sexmale age sibsp parch
                  0         0         0       1  28     0     0

> plotres(a.bag3, clip=F, trace=1, SHOWCALL=TRUE)
stats::residuals(object=bagEarth.object, type="response")
residuals() was unsuccessful
stats::predict(bagEarth.object, data.frame[3,7], type="response", clip=FALSE)
stats::fitted(object=bagEarth.object)
fitted() was unsuccessful, will use predict()
got model response from model.frame(survived~., data=call$data, na.action="na.fail")

training rsq 0.45
> 
> # example by Max Kuhn on stackoverflow
> set.seed(2015)
> etit <- etitanic
> etit$survived <- factor(ifelse(etit$survived == 1, "yes", "no"),
+                        levels = c("yes", "no"))
> # TODO pairs are not plotted
> caret.earth.mod2 <- train(survived ~ .,
+             data = etit,
+             method = "earth",
+             tuneGrid = data.frame(degree = 2, nprune = 9),
+             trControl = trainControl(method = "none",
+                                      classProbs = TRUE))
> plotmo(caret.earth.mod2, type="raw", trace=1, SHOWCALL=TRUE)
stats::predict(train.object, data.frame[3,5], type="raw")
stats::fitted(object=train.object)
got model response from model.frame(survived~pclass+s..., data=call$data, na.action="na.fail")

 grid:    pclass    sex age sibsp parch
             1st female  28     0     0

> plotres(caret.earth.mod2, type="raw", trace=1, SHOWCALL=TRUE)
stats::residuals(object=train.object, type="raw")
residuals() was unsuccessful
stats::predict(train.object, data.frame[3,5], type="raw")
stats::fitted(object=train.object)
got model response from model.frame(survived~pclass+s..., data=call$data, na.action="na.fail")

training rsq 0.21
> 
> data(ozone1)
> a <- train(O3 ~ ., data = ozone1,  method = "earth",
+             tuneGrid = data.frame(degree = 2, nprune = 14))
> plotmo(a, type="raw", trace=1, SHOWCALL=TRUE)
stats::predict(train.object, data.frame[3,9], type="raw")
stats::fitted(object=train.object)
got model response from model.frame(O3~vh+wind+humidi..., data=call$data, na.action="na.fail")

 grid:    vh wind humidity temp    ibh dpg   ibt vis   doy
        5760    5       64   62 2112.5  24 167.5 120 205.5

> plotres(a, type="raw", trace=1, SHOWCALL=TRUE)
stats::residuals(object=train.object, type="raw")
residuals() was unsuccessful
stats::predict(train.object, data.frame[3,9], type="raw")
stats::fitted(object=train.object)
got model response from model.frame(O3~vh+wind+humidi..., data=call$data, na.action="na.fail")

training rsq 0.83
> 
> library(nnet)
> data(iris3)
> set.seed(301)
> samp <- c(sample(1:50,25), sample(51:100,25), sample(101:150,25))
> ird <- data.frame(rbind(iris3[,,1], iris3[,,2], iris3[,,3]),
+                   species=factor(c(rep("seto",50), rep("vers", 50), rep("virg", 50))))
> ir.nn2 <- nnet(species ~ ., data = ird, subset = samp, size = 2, rang = 0.1,
+                decay = 5e-4, maxit = 20)
# weights:  19
initial  value 82.529015 
iter  10 value 34.571645
iter  20 value 10.461202
final  value 10.461202 
stopped after 20 iterations
> plotmo(ir.nn2, nresponse=1, type="class", all2=T, degree2=2:6)
 grid:    Sepal.L. Sepal.W. Petal.L. Petal.W.
               5.8        3      4.4      1.3
> plotmo(ir.nn2, nresponse=2, clip=F, all2=T, degree2=1:5)
 grid:    Sepal.L. Sepal.W. Petal.L. Petal.W.
               5.8        3      4.4      1.3
> plotres(ir.nn2, nresponse=2)

plotmo_y[75,1]:
    species
30     seto
7      seto
1      seto
...    seto
147    virg
  species is a factor with levels: seto vers virg

> 
> #--- fda ------------------------------------------------------------------------------
> 
> par(mfrow=c(1,1))
> 
> par(mfrow=c(4,5))
> par(mar = c(3, 2, 3, .1)) # b, l, t, r
> par(mgp = c(1.5, .5, 0))
> fda.earth <- fda(Species~., data=iris, keep.fitted=TRUE, method=earth, keepxy=TRUE)
> fda.polyreg <- fda(Species~., data=iris, keep.fitted=TRUE, keepxy=TRUE)
> fda.bruto <- fda(Species~., data=iris, keep.fitted=TRUE, method=bruto)
> 
> # 'fda.polyreg$fit' does not have a 'call' field or 'x' and 'y' fields
> expect.err(try(plotmo(fda.polyreg$fit, type="variates", nresponse=1, clip=F, do.par=F)))
Error : 'fda.polyreg$fit' does not have a 'call' field or 'x' and 'y' fields
Got error as expected
> 
> plot(1, main="plotmo with fda", xaxt="n", yaxt="n", xlab="", ylab="",
+      type="n", bty="n", cex.main=1.2, xpd=NA)
> 
> plotmo(fda.earth, type="variates", nresponse=1, clip=F, do.par=F)
 grid:    Sepal.Length Sepal.Width Petal.Length Petal.Width
                   5.8           3         4.35         1.3
> 
> plot(1, main="plotmo with fda.earth$fit", xaxt="n", yaxt="n", xlab="", ylab="",
+      type="n", bty="n", cex.main=1.2, xpd=NA)
> 
> plotmo(fda.earth$fit, nresponse=1, clip=F, do.par=F)
 grid:    Sepal.Length Sepal.Width Petal.Length Petal.Width
                   5.8           3         4.35         1.3
> 
> plot(1, main="", xaxt="n", yaxt="n", xlab="", ylab="",
+      type="n", bty="n", cex.main=1.5, xpd=NA)
> 
> plot(fda.earth)
> plotmo(fda.earth, clip=F, do.par=F) # default type is class
 grid:    Sepal.Length Sepal.Width Petal.Length Petal.Width
                   5.8           3         4.35         1.3
> 
> plot(fda.polyreg)
> plotmo(fda.polyreg, type="variates", nresponse=1, clip=F, do.par=F, degree1=c(1,3,4))
 grid:    Sepal.Length Sepal.Width Petal.Length Petal.Width
                   5.8           3         4.35         1.3
> plot(1, main="", xaxt="n", yaxt="n", xlab="", ylab="",
+      type="n", bty="n", cex.main=1.5, xpd=NA)
> 
> par(mfrow=c(3,3))
> par(mar = c(3, 2, 3, .1)) # b, l, t, r
> par(mgp = c(1.5, .5, 0))
> plot(fda.bruto)
> plotmo(fda.bruto, type="variates", nresponse=1, do.par=F)
 grid:    Sepal.Length Sepal.Width Petal.Length Petal.Width
                   5.8           3         4.35         1.3
> 
> # neural net package
> # for speed we use artificial data because neuralnet is very slow on say trees
> library(neuralnet)
Loading required package: grid
> n <- 20
> set.seed(3)
> x1 <- runif(n, min=-1, max=1)
> x2 <- runif(n, min=-1, max=1) # x2 is noise
> y <- x1^2
> data <- data.frame(y=y, x1=x1, x2=x2)
> colnames(data) <- c("y","x1", "x2")
> set.seed(3)
> nn <- neuralnet(y~x1+x2, data=data, hidden=3, rep=3)
> print(head(plotmo:::predict.nn(nn, rep="best", trace=TRUE)))
predict.nn: rep = "best" is rep = 2 
              [,1]
[1,] 0.46903929790
[2,] 0.36653551476
[3,] 0.02542869990
[4,] 0.10970959373
[5,] 0.06457524136
[6,] 0.04182985207
> plotmo(nn, trace=1, col.response=2, all2=TRUE, SHOWCALL=TRUE)
stats::predict(nn.object, data.frame[3,2], trace=TRUE)
predict.nn: rep = "mean" will take the mean of 3 reps
stats::fitted(object=nn.object)
fitted() was unsuccessful, will use predict()
got model response from model.frame(y~x1+x2, data=object$data, na.action="na.fail")

   grid:    x1            x2
 0.09128478914 -0.2904530708

> plotmo(nn, trace=1, col.response=2, predict.rep="best", SHOWCALL=TRUE)
stats::predict(nn.object, data.frame[3,2], trace=TRUE, rep="best")
predict.nn: rep = "best" is rep = 2 
stats::fitted(object=nn.object)
fitted() was unsuccessful, will use predict()
got model response from model.frame(y~x1+x2, data=object$data, na.action="na.fail")

   grid:    x1            x2
 0.09128478914 -0.2904530708

> plotres(nn, trace=1, info=TRUE, SHOWCALL=TRUE)
stats::residuals(object=nn.object, type="response")
residuals() was unsuccessful
stats::predict(nn.object, data.frame[3,2], trace=TRUE)
predict.nn: rep = "mean" will take the mean of 3 reps
stats::fitted(object=nn.object)
fitted() was unsuccessful, will use predict()
got model response from model.frame(y~x1+x2, data=object$data, na.action="na.fail")

training rsq 0.99
> plotres(nn, trace=1, info=TRUE, predict.rep="best", SHOWCALL=TRUE)
stats::residuals(object=nn.object, type="response")
residuals() was unsuccessful
stats::predict(nn.object, data.frame[3,2], trace=TRUE, rep="best")
predict.nn: rep = "best" is rep = 2 
stats::fitted(object=nn.object)
fitted() was unsuccessful, will use predict()
got model response from model.frame(y~x1+x2, data=object$data, na.action="na.fail")

training rsq 0.99
> 
> library(biglm)
Loading required package: DBI
> data(trees)
> ff <- log(Volume)~log(Girth)+log(Height)
> chunk1 <- trees[1:20,]
> chunk2 <- trees[20:31,]
> biglm <- biglm(ff,chunk1)
> biglm <- update(biglm, chunk2)
> plotmo(biglm, pt.col=2, SHOWCALL=TRUE)
 grid:    Girth Height
          11.25     75
> plotres(biglm, SHOWCALL=TRUE)
Warning: plotting 20 cases but the model was built with 32 cases

> 
> if(!interactive()) {
+     dev.off()         # finish postscript plot
+     q(runLast=FALSE)  # needed else R prints the time on exit (R2.5 and higher) which messes up the diffs
+ }
