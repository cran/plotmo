> # test.plotmo.rpart.R: test plotmo on non-earth models
> # Stephen Milborrow, Basley KwaZulu-Natal Mar 2011
> 
> library(plotmo)
> library(earth)
Loading required package: plotrix
> data(ozone1)
> data(etitanic)
> options(warn=1) # print warnings as they occur
> if(!interactive())
+     postscript(paper="letter")
> Trace <- 0
> dopar <- function(nrows, ncols, caption = "")
+ {
+     cat("                             ", caption, "\n")
+     earth:::make.space.for.caption(caption)
+     par(mfrow=c(nrows, ncols))
+     par(mar = c(3, 3, 1.7, 0.5))
+     par(mgp = c(1.6, 0.6, 0))
+     par(cex = 0.7)
+ }
> expect.err <- function(obj) # test that we got an error as expected from a try() call
+ {
+     if(class(obj)[1] == "try-error")
+         cat("Got error as expected\n")
+     else
+         stop("did not get expected try error")
+ }
> caption <- "test lm(log(doy) ~ vh+wind+humidity+temp+log(ibh), data=ozone1)"
> dopar(4,5,caption)
                              test lm(log(doy) ~ vh+wind+humidity+temp+log(ibh), data=ozone1) 
> a <- lm(log(doy) ~ vh + wind + humidity + temp + log(ibh), data=ozone1)
> plotmo(a, do.par=FALSE, caption=caption, ylim=NA, col.response=3, pch.response=20, trace=Trace, col.smooth="indianred")

 grid:    vh wind humidity temp    ibh
        5760    5       64   62 2112.5

> termplot(a)
> 
> caption <- "test lm(log(doy) ~ vh+wind+humidity+I(wind*humidity)+temp+log(ibh), data=ozone1)"
> dopar(4,5,caption)
                              test lm(log(doy) ~ vh+wind+humidity+I(wind*humidity)+temp+log(ibh), data=ozone1) 
> a <- lm(log(doy) ~ vh + wind + humidity + temp + log(ibh), data=ozone1)
> plotmo(a, do.par=FALSE, caption=caption, ylim=NA, col.resp=3, pch.response=20, clip=FALSE, trace=Trace, col.smooth="indianred")

 grid:    vh wind humidity temp    ibh
        5760    5       64   62 2112.5

> termplot(a)
> 
> caption <- "test lm(doy ~ (vh+wind+humidity)^2, data=ozone1)"
> dopar(4,3,caption)
                              test lm(doy ~ (vh+wind+humidity)^2, data=ozone1) 
> a <- lm(doy ~ (vh+wind+humidity)^2, data=ozone1)
> plotmo(a, do.par=FALSE, caption=caption, ylim=NULL, trace=Trace)

 grid:    vh wind humidity
        5760    5       64

> # termplot(a) # termplot fails with Error in `[.data.frame`(mf, , i): undefined columns selected
> 
> caption <- "test lm(doy^2 ~ vh+wind+humidity+I(wind*humidity)+temp+log(ibh), data=ozone1)"
> dopar(4,3,caption)
                              test lm(doy^2 ~ vh+wind+humidity+I(wind*humidity)+temp+log(ibh), data=ozone1) 
> a <- lm(doy^2 ~ vh+wind+humidity+I(wind*humidity)+temp+log(ibh), data=ozone1)
> plotmo(a, do.par=FALSE, caption=caption, ylim=NULL, trace=Trace)

 grid:    vh wind humidity temp    ibh
        5760    5       64   62 2112.5

> termplot(a) # termplot draws a funky second wind plot
> 
> caption <- "test lm with data=ozone versus attach(ozone)"
> dopar(4,3,caption)
                              test lm with data=ozone versus attach(ozone) 
> a <- lm(log(doy) ~ I(vh*wind) + wind + I(humidity*temp) + log(ibh), data=ozone1)
> plotmo(a, do.par=FALSE, caption=caption, degree1=c(1,2,4,5), trace=Trace)

 grid:    vh wind humidity temp    ibh
        5760    5       64   62 2112.5

> attach(ozone1)
> a <- lm(log(doy) ~ I(vh*wind) + wind + I(humidity*temp) + log(ibh))
> plotmo(a, do.par=FALSE, degree1=c(1,2,4,5), trace=Trace)

 grid:    vh wind humidity temp    ibh
        5760    5       64   62 2112.5

> detach(ozone1)
> 
> # commented out because "$" in names is not yet supported
> # a <- lm(log(ozone1$doy) ~ I(ozone1$vh*ozone1$wind) + log(ozone1$ibh))
> # plotmo(a, trace=Trace)
> 
> set.seed(1)
> caption <- "test glm, glm(cbind(damage, 6-damage) ~ temp, family=binomial, data=orings)"
> dopar(2,2,caption)
                              test glm, glm(cbind(damage, 6-damage) ~ temp, family=binomial, data=orings) 
> library(faraway)
> data(orings)
> a <- lm(damage/6 ~ temp, data=orings)
> plotmo(a, do.par=FALSE, caption=caption, col.response="pink", clip=FALSE, nrug=-1, ylim=c(0,1),
+     main="lm(damage/6 ~ temp, data=orings)", trace=Trace, col.smooth="indianred")
> a <- glm(cbind(damage, 6-damage) ~ temp, family=binomial, data=orings)
> plotmo(a, do.par=FALSE, caption=caption, col.response="pink", clip=FALSE, nrug=-1, ylim=c(0,1),
+     main="glm(cbind(damage, 6-damage) ~ temp, family=binomial, data=orings)", trace=Trace, col.smooth="indianred")
> termplot(a)
> par(mfrow=c(2,2))
> plotmo(a, type="link", main="type=\"link\" glm family=binom data=orings", trace=Trace, do.par=F)
> plotmo(a, type="response", main="type=\"response\" glm family=binom data=orings", trace=Trace, do.par=F)
> par(mfrow=c(1,1))
> 
> set.seed(1)
> caption <- "test glm(lot2~log(u),data=clotting,family=Gamma)"
> dopar(2,2,caption)
                              test glm(lot2~log(u),data=clotting,family=Gamma) 
> u = c(5,10,15,20,30,40,60,80,100)
> lota = c(118,58,42,35,27,25,21,19,18)
> clotting <- data.frame(u = u, lota = lota)
> a <- glm(lota ~ log(u), data=clotting, family=Gamma)
> plotmo(a, do.par=FALSE, caption=caption, col.response=3, clip=FALSE, nrug=-1, trace=Trace)
> termplot(a)
> plotmo(a, type="link", caption=paste("type=\"link\"", caption))
> 
> if(length(grep("package:gam", search())))
+     detach("package:gam")
> library(mgcv)
Loading required package: nlme
This is mgcv 1.8-3. For overview type 'help("mgcv-package")'.
> set.seed(1)
> caption <- "test plot.gam, with mgcv::gam(y ~ s(x) + s(x,z)) with response and func (and extra image plot)"
> dopar(3,2,caption)
                              test plot.gam, with mgcv::gam(y ~ s(x) + s(x,z)) with response and func (and extra image plot) 
> par(mar = c(3, 5, 1.7, 0.5))    # more space for left and bottom axis
> test1 <- function(x,sx=0.3,sz=0.4)
+     (pi**sx*sz)*(1.2*exp(-(x[,1]-0.2)^2/sx^2-(x[,2]-0.3)^2/sz^2)+
+     0.8*exp(-(x[,1]-0.7)^2/sx^2-(x[,2]-0.8)^2/sz^2))
> n <- 100
> set.seed(1)
> x <- runif(n);
> z <- runif(n);
> y <- test1(cbind(x,z)) + rnorm(n) * 0.1
> a <- gam(y ~ s(x) + s(x,z))
> # this also tests degree1 axis settings like col.lab
> plotmo(a, do.par=FALSE, type2="contour", caption=caption, col.response=3, col.smooth="indianred",
+       func=test1, col.func="indianred", lwd.func=5, lty.func=2, trace=2,
+       col.axis=4, col.lab=2, font=2, font.axis=3, lab=c(2,2,7), lwd.smooth=3, mgp=c(.1,.5,.2))
Using env attr(object$terms, ".Environment")

--get.plotmo.x for gam object

formula y ~ s(x) + s(x, z)
stripped formula y~x+x+z
no explicit data for formula
about to eval model.frame(formula=y~x+x+z)
got x with colnames from object$call$formula

x[100,2]:
            x         z
1   0.2655087 0.6547239
2   0.3721239 0.3531973
3   0.5728534 0.2702601
... 0.9082078 0.9926841
100 0.6049333 0.7828513

nlevels: x=100 z=100 

--get.plotmo.y for gam object

got y from object$y
get.plotmo.y returned length 100 min -0.09294014 max 0.8425504
             value 0.2803529 0.5217916 0.1177545 0.2369002 0.2962403 0.2134538 0.08681319 0.3755435 0.4335776 0.485286 ...

clip.limits -0.09294014 0.8425504 

--get.plotmo.singles for gam object

singles: 1 x, 2 z 

--get.plotmo.pairs for gam object

term.labels: s(x) s(x, z) 
considering s(x)
considering s(x:z)-> x z at 1 2
pairs:
     [,1]  [,2] 
[1,] "1 x" "2 z"

--plot.degree1(draw.plot=FALSE)

plotmo.predict(type="response") for degree1 plot "x" with newdata[50,2]:
             x         z
1   0.01339033 0.5185988
2   0.03336004 0.5185988
3   0.05332975 0.5185988
... 0.07329946 0.5185988
50  0.99190609 0.5185988

predict.gam(xgrid, type="response") returned length 50 min 0.1783782 max 0.4979262
                                    value 0.3863872 0.3939398 0.4019455 0.410471 0.4195786 0.4293108 0.4396554 0.45035 0.4610606 0.4712948 ...

plotmo.predict(type="response") for degree1 plot "z" with newdata[50,2]:
            x          z
1   0.4878107 0.01307758
2   0.4878107 0.03306954
3   0.4878107 0.05306151
... 0.4878107 0.07305348
50  0.4878107 0.99268406

predict.gam(xgrid, type="response") returned length 50 min 0.193361 max 0.4118666
                                    value 0.193361 0.201246 0.2102896 0.2202034 0.2307204 0.2415487 0.2524108 0.2631668 0.2737087 0.2839172 ...

--plot.degree2(draw.plot=FALSE)

plotmo.predict(type="response") for degree2 plot "x:z" with newdata[400,2]:
             x          z
1   0.01339033 0.01307758
2   0.06489116 0.01307758
3   0.11639199 0.01307758
... 0.16789282 0.01307758
400 0.99190609 0.99268406

predict.gam(xgrid, type="response") returned length 400 min -0.03239347 max 0.5841616
                                    value 0.5320208 0.524147 0.5110715 0.4916667 0.4647756 0.4294505 0.3851978 0.3322193 0.2718122 0.2070933 ...

ylim -0.09294014 0.8425504 

--plot.degree1(draw.plot=TRUE)

 grid:    x         z
  0.4878107 0.5185988


Applying "func" arg to
           x         z
1 0.01339033 0.5185988
2 0.03336004 0.5185988
3 0.05332975 0.5185988
func=test1 returned length 50 min 0.1071762 max 0.5207568
           value 0.3423716 0.3706791 0.3978903 0.4234688 0.4468962 0.4676942 0.4854453 0.4998123 0.5105547 0.5175411 ...

Applying "func" arg to
          x          z
1 0.4878107 0.01307758
2 0.4878107 0.03306954
3 0.4878107 0.05306151
func=test1 returned length 50 min 0.1668464 max 0.3675085
           value 0.1668464 0.1796153 0.1925092 0.205434 0.2182929 0.2309886 0.2434258 0.2555129 0.2671644 0.278303 ...

--plot.degree2(draw.plot=TRUE)

> plotmo(a, do.par=FALSE, degree1=F, degree2=1, type2="image", ylim=NA, trace=Trace)
> plot(a, select=1)
> plot(a, select=2)
> plot(a, select=3)
> n<-400
> sig<-2
> set.seed(1)
> x0 <- runif(n, 0, 1)
> x1 <- runif(n, 0, 1)
> x2 <- runif(n, 0, 1)
> x3 <- runif(n, 0, 1)
> f0 <- function(x) 2 * sin(pi * x)
> f1 <- function(x) exp(2 * x)
> f2 <- function(x) 0.2*x^11*(10*(1-x))^6+10*(10*x)^3*(1-x)^10
> f <- f0(x0) + f1(x1) + f2(x2)
> e <- rnorm(n, 0, sig)
> y <- f + e
> test.func <- function(x) f0(x[,1]) + f1(x[,2]) + f2(x[,3])
> library(mgcv)
> caption <- "test mgcv::gam(y~s(x0,x1,k=12)+s(x2)+s(x3,k=20,fx=20)) (and extra persp plot)"
> dopar(3,3,caption)
                              test mgcv::gam(y~s(x0,x1,k=12)+s(x2)+s(x3,k=20,fx=20)) (and extra persp plot) 
> a <- gam(y~s(x0,x1,k=12)+s(x2)+s(x3,k=20,fx=20))
> plot(a, select=2)
> plot(a, select=3)
> plot(a, select=1)
> plotmo(a, do.par=FALSE, type2="contour", caption=caption, xlab=NULL, main="", func=test.func, trace=Trace, ngrid2=10, drawlabels=FALSE)

 grid:    x0        x1        x2       x3
    0.474141 0.5151294 0.4460308 0.479208

> plotmo(a, do.par=FALSE, degree1=F, degree2=1, theta=-35, trace=Trace)
> 
> set.seed(1)
> caption <- "test plot.gam, with mgcv::gam(doy~s(wind)+s(humidity,wind)+s(vh)+temp,data=ozone1)"
> dopar(3,3,caption)
                              test plot.gam, with mgcv::gam(doy~s(wind)+s(humidity,wind)+s(vh)+temp,data=ozone1) 
> a <- gam(doy ~ s(wind) + s(humidity,wind) + s(vh) + temp, data=ozone1)
> plotmo(a, do.par=FALSE, caption=caption, type2="contour", degree1=c(1,3), swapxy=T, xlab=NULL, main="", clip=FALSE, trace=Trace)

 grid:    wind humidity   vh temp
             5       64 5760   62

> plot(a, select=1)
> plot(a, select=3)
> plot(a, select=2)
> plot(a, select=4)
> 
> # TODO Following commented out because it no longer works.  Following message from predict:
> #     Error in gam.lo(data[["lo(Wind, Temp)"]], z, w, span = 0.5, degree = 1,  :
> #         NA/NaN/Inf in foreign function call (arg 6)
> # detach("package:mgcv")
> # library(gam)
> # caption <- "test gam:gam(Ozone^(1/3)~lo(Solar.R)+lo(Wind, Temp),data=airquality)"
> # set.seed(1)
> # dopar(3,2,caption)
> # data(airquality)
> # airquality <- na.omit(airquality)   # plotmo doesn't know how to deal with NAs yet
> # a <- gam(Ozone^(1/3) ~ lo(Solar.R) + lo(Wind, Temp), data = airquality)
> # plotmo(a, do.par=FALSE, caption=caption, ylim=NA, col.response=3, trace=Trace)
> # # termplot gives fishy looking wind plot, plotmo looks ok
> # # termplot(a) #TODO this fails with R2.5: dim(data) <- dim: attempt to set an attribute on NULL
> # detach("package:gam")
> 
> library(mda)
Loading required package: class
Loaded mda 0.4-4

> caption <- "test mars and earth (expect not a close match)"
> dopar(6,3,caption)
                              test mars and earth (expect not a close match) 
> a <- mars( ozone1[, -1], ozone1[,1], degree=2)
> b <- earth(ozone1[, -1], ozone1[,1], degree=2)
> plotmo(a, do.par=FALSE, caption=caption, trace=Trace)

 grid:    vh wind humidity temp    ibh dpg   ibt vis   doy
        5760    5       64   62 2112.5  24 167.5 120 205.5

> plotmo(b, do.par=FALSE, trace=Trace)

 grid:    vh wind humidity temp    ibh dpg   ibt vis   doy
        5760    5       64   62 2112.5  24 167.5 120 205.5

> 
> caption <- "test mars and mars.to.earth(mars) (expect no degree2 for mars)"
> dopar(6,3,caption)
                              test mars and mars.to.earth(mars) (expect no degree2 for mars) 
> a <- mars(ozone1[, -1], ozone1[,1], degree=2)
> b <- mars.to.earth(a)
Converted mars(x=ozone1[, -1], y=ozone1[, 1], degree=2)

to        earth(x=ozone1[, -1], y=ozone1[, 1], degree=2)

> plotmo(a, do.par=FALSE, caption=caption, ylim=NA, trace=Trace)

 grid:    vh wind humidity temp    ibh dpg   ibt vis   doy
        5760    5       64   62 2112.5  24 167.5 120 205.5

> plotmo(b, do.par=FALSE, ylim=NA, trace=Trace)

 grid:    vh wind humidity temp    ibh dpg   ibt vis   doy
        5760    5       64   62 2112.5  24 167.5 120 205.5

> 
> # check fix for bug reported by Martin Maechler:
> # form <- Volume ~ .; a <- earth(form, data = trees); plotmo(a) fails
> 
> dopar(4,4, "test f <- O3 ~ .; a <- earth(f, data=ozone1)")
                              test f <- O3 ~ .; a <- earth(f, data=ozone1) 
> fa <- log(O3) ~ .
> a <- earth(fa, data=ozone1, degree=2)
> print(summary(a))
Call: earth(formula=fa, data=ozone1, degree=2)

                             coefficients
(Intercept)                    2.74534462
h(temp-52)                     0.01907462
h(12-dpg)                     -0.00925363
h(dpg-12)                     -0.00610244
h(194-ibt)                    -0.00528412
h(200-vis)                     0.00219982
h(92-doy)                     -0.01418022
h(doy-92)                     -0.00232883
h(wind-8) * h(200-vis)        -0.00364958
h(humidity-73) * h(52-temp)   -0.00648895
h(humidity-51) * h(ibh-1108)  -0.00000300
h(1108-ibh) * h(doy-305)      -0.00001180
h(1108-ibh) * h(305-doy)      -0.00000120

Selected 13 of 21 terms, and 8 of 9 predictors 
Termination condition: Reached nk 21
Importance: temp, dpg, ibt, humidity, ibh, doy, vis, wind, vh-unused
Number of terms at each degree of interaction: 1 7 5
GCV 0.106792    RSS 28.93126    GRSq 0.80989    RSq 0.8429798
> plot(a, do.par=FALSE)
> plotmo(a, do.par=FALSE, degree1=2:3, degree2=c(1,2), col.response = "pink", col.smooth="indianred")

 grid:    vh wind humidity temp    ibh dpg   ibt vis   doy
        5760    5       64   62 2112.5  24 167.5 120 205.5

> a <- lm(log(doy) ~ I(vh*wind) + I(humidity*temp) + log(ibh), data=ozone1)
> plotmo(a, do.par=FALSE, degree1=1:2)

 grid:    vh wind humidity temp    ibh
        5760    5       64   62 2112.5

> fa <- log(doy) ~ I(vh*wind) + I(humidity*temp) + log(ibh)
> a <- lm(fa, data=ozone1)
> plotmo(a, do.par=FALSE, degree1=1:2)

 grid:    vh wind humidity temp    ibh
        5760    5       64   62 2112.5

> 
> # test inverse.func and func
> 
> caption <- "test inverse.func=exp"
> a <- lm(log(Volume) ~ Girth + Height + I(Girth*Height), data=trees)
> my.func <- function(x) -60 + 5 * x[,1] + x[,2] / 3
> plotmo(a, caption=caption, inverse.func = exp, col.response = "pink", func=my.func, col.func="gray", ngrid1=1000, type2="p", trace=1, col.smooth="indianred")
Using env attr(object$terms, ".Environment")

--get.plotmo.x for lm object

get.data.for.formula: using x from "trees" passed to lm 
got x with colnames from object$call$formula

x[31,2]:
    Girth Height
1     8.3     70
2     8.6     65
3     8.8     63
...  10.5     72
31   20.6     87

nlevels: Girth=27 Height=21 

--get.plotmo.y for lm object

get.data.for.formula: using y from "trees" passed to lm 
got y from object$call$formula
get.plotmo.y returned length 31 min 2.322388 max 4.343805
             value 2.332144 2.332144 2.322388 2.797281 2.933857 2.980619 2.747271 2.901422 3.11795 2.99072 ...
inverse.func=exp returned length 31 min 10.2 max 77
                 value 10.3 10.3 10.2 16.4 18.8 19.7 15.6 18.2 22.6 19.9 ...

clip.limits 10.2 77 

--plot.degree1(draw.plot=FALSE)

plotmo.predict(type="response") for degree1 plot "Girth" with newdata[27,2]:
    Girth Height
1     8.3     76
2     8.6     76
3     8.8     76
...  10.5     76
27   20.6     76

predict.lm(xgrid, type="response") returned length 27 min 2.548812 max 4.407664
                                   value 2.548812 2.59415 2.624375 2.88129 2.911515 2.926628 2.956853 2.971966 2.987078 3.002191 ...
inverse.func=exp returned length 27 min 12.7919 max 82.07748
                 value 12.7919 13.38521 13.79596 17.83727 18.38463 18.66458 19.23734 19.53027 19.82766 20.12959 ...

--plot.degree2(draw.plot=FALSE)

plotmo.predict(type="response") for degree2 plot "Girth:Height" with newdata[400,2]:
        Girth Height
1    8.300000     63
2    8.947368     63
3    9.594737     63
... 10.242105     63
400 20.600000     87

predict.lm(xgrid, type="response") returned length 400 min 2.216637 max 4.455988
                                   value 2.216637 2.334497 2.452358 2.570218 2.688079 2.80594 2.9238 3.041661 3.159521 3.277382 ...
inverse.func=exp returned length 400 min 9.176416 max 86.14119
                 value 9.176416 10.32427 11.6157 13.06868 14.7034 16.54261 18.61188 20.93999 23.55932 26.50629 ...

ylim 10.2 77 

 grid:    Girth Height
           12.9     76


Applying "func" arg to
  Girth Height
1   8.3     76
2   8.6     76
3   8.8     76
func=my.func returned length 27 min 6.833333 max 68.33333
             value 6.833333 8.333333 9.333333 17.83333 18.83333 19.33333 20.33333 20.83333 21.33333 21.83333 ...

Applying "func" arg to
  Girth Height
1  12.9     63
2  12.9     64
3  12.9     65
func=my.func returned length 21 min 25.5 max 33.5
             value 25.5 25.83333 26.16667 26.5 27.5 27.83333 28.16667 28.5 29.16667 29.5 ...
persp(Girth:Height) theta 235 ylim 10.2 77 cex 0.83
> 
> # se testing
> 
> caption = "level=.95, lm(doy~., data=ozone1) versus termplot"
> dopar(6,3,caption)
                              level=.95, lm(doy~., data=ozone1) versus termplot 
> a <- lm(doy~., data=ozone1)
> plotmo(a, level=.95, do.par=FALSE, trace=1, caption=caption)
Using env attr(object$terms, ".Environment")

--get.plotmo.x for lm object

get.data.for.formula: using x from "ozone1" passed to lm 
got x with colnames from object$call$formula

x[330,9]:
    O3   vh wind humidity temp  ibh dpg ibt vis
1    3 5710    4       28   40 2693 -25  87 250
2    5 5700    3       37   45  590 -24 128 100
3    5 5760    3       51   54 1450  25 139  60
...  6 5720    4       69   35 1568  15 121  60
330  1 5550    4       85   39 5000   8  44 100

nlevels: O3=35 vh=53 wind=11 humidity=65 temp=63 ibh=196 dpg=128 ibt=193 vis=24 

--get.plotmo.y for lm object

get.data.for.formula: using y from "ozone1" passed to lm 
got y from object$call$formula
get.plotmo.y returned length 330 min 33 max 390
             value 33 34 35 36 37 38 39 40 41 42 ...

clip.limits 33 390 

--plot.degree1(draw.plot=FALSE)

plotmo.predict(type="response") for degree1 plot "O3" with newdata[35,9]:
    O3   vh wind humidity temp    ibh dpg   ibt vis
1    1 5760    5       64   62 2112.5  24 167.5 120
2    2 5760    5       64   62 2112.5  24 167.5 120
3    3 5760    5       64   62 2112.5  24 167.5 120
...  4 5760    5       64   62 2112.5  24 167.5 120
35  38 5760    5       64   62 2112.5  24 167.5 120

predict.lm(xgrid, type="response") returned length 35 min 110.3949 max 242.8995
                                   value 242.8995 239.3182 235.737 232.1558 228.5746 224.9934 221.4122 217.831 214.2498 210.6686 ...

plotmo.predict(type="response", level=0.95) for degree1 plot "O3" with newdata[35,9]:
    O3   vh wind humidity temp    ibh dpg   ibt vis
1    1 5760    5       64   62 2112.5  24 167.5 120
2    2 5760    5       64   62 2112.5  24 167.5 120
3    3 5760    5       64   62 2112.5  24 167.5 120
...  4 5760    5       64   62 2112.5  24 167.5 120
35  38 5760    5       64   62 2112.5  24 167.5 120


--plotmo.pint for lm object

prediction intervals[35,4]:
          lwr      upr  cint.lwr cint.upr
1    67.64766 418.1512 215.71574 270.0832
2    64.35886 414.2776 214.08831 264.5482
3    61.04425 410.4298 212.42750 259.0466
...  57.70371 406.6080 210.72433 253.5873
35  -71.38703 292.1768  54.98347 165.8063


ylim -91.66387 490.7928 

 grid:    O3   vh wind humidity temp    ibh dpg   ibt vis
          10 5760    5       64   62 2112.5  24 167.5 120

> termplot(a, se=2)
> 
> caption <- "test different se options, level=.95, lm(log(doy)~vh+wind+log(humidity),data=ozone1)"
> dopar(4,3,caption)
                              test different se options, level=.95, lm(log(doy)~vh+wind+log(humidity),data=ozone1) 
> a <- lm(log(doy) ~ vh + wind + log(humidity), data=ozone1)
> plotmo(a, do.par=FALSE, caption=caption, ylim=NA, level=.95, trace=2)
Using env attr(object$terms, ".Environment")

--get.plotmo.x for lm object

formula log(doy) ~ vh + wind + log(humidity)
stripped formula log(doy)~vh+wind+humidity
get.data.for.formula: using x from "ozone1" passed to lm 
about to eval model.frame(formula=log(doy)~vh+wind+humidity, data=structure(list(
    O3=c(3, 5, 5, 6, 4, 4, 6, 7, 4, 6, 5, 4, 4, 7, 5, 9, 4, 
    3, 4, 4, 5, 6, 9, 6, 6, 11, 10, 7, 12, 9, 2, 3, 3, 2, 3, 
    3, 4, 6, 8, 6, 4, 3, 7, 11, 13, 6, 5, 4, 4, 6, 10, 15, 23, 
    17, 7, 2, 3, 3, 4, 6, 7, 7, 6, 3, 2, 8, 12, 12, 16, 9, 24, 
    13, 8, 10, 8, 9, 10, 14, 9, 11, 7, 9, 12, 12, 8, 9, 5, 4, 
    4, 9, 13, 5, 10, 10, 7, 5, 4, 7, 3, 4, 7, 11, 15, 22, 17, 
    7, 10, 19, 18, 12, 6, 9, 19, 21, 29, 16, 11, 2, 12, 16, 22, ...
got x with colnames from object$call$formula

x[330,3]:
      vh wind humidity
1   5710    4       28
2   5700    3       37
3   5760    3       51
... 5720    4       69
330 5550    4       85

nlevels: vh=53 wind=11 humidity=65 

--get.plotmo.y for lm object

formula log(doy) ~ vh + wind + log(humidity)
stripped formula log(doy)~vh+wind+humidity
get.data.for.formula: using y from "ozone1" passed to lm 
about to eval model.frame(formula=log(doy)~vh+wind+humidity, data=structure(list(
    O3=c(3, 5, 5, 6, 4, 4, 6, 7, 4, 6, 5, 4, 4, 7, 5, 9, 4, 
    3, 4, 4, 5, 6, 9, 6, 6, 11, 10, 7, 12, 9, 2, 3, 3, 2, 3, 
    3, 4, 6, 8, 6, 4, 3, 7, 11, 13, 6, 5, 4, 4, 6, 10, 15, 23, 
    17, 7, 2, 3, 3, 4, 6, 7, 7, 6, 3, 2, 8, 12, 12, 16, 9, 24, 
    13, 8, 10, 8, 9, 10, 14, 9, 11, 7, 9, 12, 12, 8, 9, 5, 4, 
    4, 9, 13, 5, 10, 10, 7, 5, 4, 7, 3, 4, 7, 11, 15, 22, 17, 
    7, 10, 19, 18, 12, 6, 9, 19, 21, 29, 16, 11, 2, 12, 16, 22, ...
got y from object$call$formula
get.plotmo.y returned length 330 min 3.496508 max 5.966147
             value 3.496508 3.526361 3.555348 3.583519 3.610918 3.637586 3.663562 3.688879 3.713572 3.73767 ...

clip.limits 3.496508 5.966147 

--get.plotmo.singles for lm object

singles: 1 vh, 2 wind, 3 humidity 

--get.plotmo.pairs for lm object

get.data.for.formula: using x from "ozone1" passed to lm 
term.labels: vh wind log(humidity) 
considering vh
considering wind
considering log(humidity)
no pairs

ylim NA NA 

--plot.degree1(draw.plot=TRUE)

 grid:    vh wind humidity
        5760    5       64


plotmo.predict(type="response") for degree1 plot "vh" with newdata[50,3]:
          vh wind humidity
1   5320.000    5       64
2   5332.857    5       64
3   5345.714    5       64
... 5358.571    5       64
50  5950.000    5       64

predict.lm(xgrid, type="response") returned length 50 min 4.383936 max 5.596516
                                   value 4.383936 4.408682 4.433429 4.458175 4.482922 4.507668 4.532415 4.557161 4.581908 4.606655 ...

plotmo.predict(type="response", level=0.95) for degree1 plot "vh" with newdata[50,3]:
          vh wind humidity
1   5320.000    5       64
2   5332.857    5       64
3   5345.714    5       64
... 5358.571    5       64
50  5950.000    5       64


--plotmo.pint for lm object

prediction intervals[50,4]:
         lwr      upr cint.lwr cint.upr
1   3.202805 5.565067 4.109051 4.658820
2   3.229314 5.588050 4.141473 4.675891
3   3.255773 5.611085 4.173881 4.692977
... 3.282180 5.634170 4.206272 4.710079
50  4.439332 6.753700 5.456635 5.736397


plotmo.predict(type="response") for degree1 plot "wind" with newdata[11,3]:
      vh wind humidity
1   5760    0       64
2   5760    2       64
3   5760    3       64
... 5760    4       64
11  5760   11       64

predict.lm(xgrid, type="response") returned length 11 min 5.023502 max 5.40358
                                   value 5.40358 5.334475 5.299922 5.26537 5.230817 5.196265 5.161712 5.12716 5.092607 5.058055 ...

plotmo.predict(type="response", level=0.95) for degree1 plot "wind" with newdata[11,3]:
      vh wind humidity
1   5760    0       64
2   5760    2       64
3   5760    3       64
... 5760    4       64
11  5760   11       64


--plotmo.pint for lm object

prediction intervals[11,4]:
         lwr      upr cint.lwr cint.upr
1   4.242108 6.565052 5.231802 5.575358
2   4.179878 6.489072 5.217919 5.451030
3   4.147480 6.452364 5.207110 5.392734
... 4.114220 6.416519 5.190294 5.340446
11  3.857262 6.189742 4.821989 5.225015


plotmo.predict(type="response") for degree1 plot "humidity" with newdata[50,3]:
      vh wind humidity
1   5760    5 19.00000
2   5760    5 20.51020
3   5760    5 22.02041
... 5760    5 23.53061
50  5760    5 93.00000

predict.lm(xgrid, type="response") returned length 50 min 4.969591 max 5.311203
                                   value 4.969591 4.986043 5.001325 5.015593 5.028973 5.04157 5.053469 5.064745 5.075459 5.085664 ...

plotmo.predict(type="response", level=0.95) for degree1 plot "humidity" with newdata[50,3]:
      vh wind humidity
1   5760    5 19.00000
2   5760    5 20.51020
3   5760    5 22.02041
... 5760    5 23.53061
50  5760    5 93.00000


--plotmo.pint for lm object

prediction intervals[50,4]:
         lwr      upr cint.lwr cint.upr
1   3.809701 6.129482 4.808853 5.130330
2   3.827479 6.144607 4.835172 5.136914
3   3.843904 6.158747 4.859496 5.143155
... 3.859161 6.172025 4.882076 5.149110
50  4.158159 6.464248 5.211191 5.411216

> plotmo(a, do.par=FALSE, caption=caption, ylim=NA, level=.95, shade.pints="pink", shade2.pints=3, trace=Trace)

 grid:    vh wind humidity
        5760    5       64

> plotmo(a, do.par=FALSE, caption=caption, ylim=NA, level=.95, shade.pints=3, trace=Trace)

 grid:    vh wind humidity
        5760    5       64

> plotmo(a, do.par=FALSE, caption=caption, ylim=NULL, level=.95, shade.pints=3, trace=Trace)

 grid:    vh wind humidity
        5760    5       64

> 
> caption <- "test level=.95, lm(log(doy)~vh+wind+log(humidity),data=ozone1)"
> dopar(2,3,caption)
                              test level=.95, lm(log(doy)~vh+wind+log(humidity),data=ozone1) 
> a <- lm(log(doy) ~ vh + wind + log(humidity), data=ozone1)
> plotmo(a, do.par=FALSE, caption=caption, ylim=NA, level=.95, trace=Trace)

 grid:    vh wind humidity
        5760    5       64

> termplot(a, se=2)
> 
> caption <- "test level=.95 and inverse.func, lm(log(doy)~vh+wind+log(humidity),data=ozone1)"
> dopar(3,3,caption)
                              test level=.95 and inverse.func, lm(log(doy)~vh+wind+log(humidity),data=ozone1) 
> a <- lm(log(doy) ~ vh + wind + log(humidity), data=ozone1)
> plotmo(a, do.par=FALSE, caption=caption, ylim=NA, level=.95, trace=Trace)

 grid:    vh wind humidity
        5760    5       64

> plotmo(a, do.par=FALSE, caption=caption, ylim=NULL, level=.95, inverse.func=exp, trace=Trace)

 grid:    vh wind humidity
        5760    5       64

> termplot(a, se=2)
> 
> caption <- "test level=.95, glm(lot2~log(u),data=clotting,family=Gamma)"
> set.seed(1)
> dopar(2,2,caption)
                              test level=.95, glm(lot2~log(u),data=clotting,family=Gamma) 
> u = c(5,10,15,20,30,40,60,80,100)
> lota = c(118,58,42,35,27,25,21,19,18)
> clotting <- data.frame(u = u, lota = lota)
> a <- glm(lota ~ log(u), data=clotting, family=Gamma)
> plotmo(a, do.par=FALSE, caption=caption, col.response=4, pch.response=7, clip=FALSE, nrug=-1, level=.95, trace=Trace, col.smooth="indianred")
Warning: the level argument may not be properly supported on this object built with weights
> termplot(a, se=2)
> 
> if(length(grep("package:gam", search())))
+     detach("package:gam")
> library(mgcv)
> set.seed(1)
> caption <- "test level=.95, plot.gam, with mgcv::gam(y ~ s(x) + s(x,z)) with response and func (and extra image plot)"
> dopar(3,2,caption)
                              test level=.95, plot.gam, with mgcv::gam(y ~ s(x) + s(x,z)) with response and func (and extra image plot) 
> par(mar = c(3, 5, 1.7, 0.5))    # more space for left and bottom axis
> test1 <- function(x,sx=0.3,sz=0.4)
+     (pi**sx*sz)*(1.2*exp(-(x[,1]-0.2)^2/sx^2-(x[,2]-0.3)^2/sz^2)+
+     0.8*exp(-(x[,1]-0.7)^2/sx^2-(x[,2]-0.8)^2/sz^2))
> n <- 100
> set.seed(1)
> x <- runif(n);
> z <- runif(n);
> y <- test1(cbind(x,z)) + rnorm(n) * 0.1
> a <- gam(y ~ s(x) + s(x,z))
> plotmo(a, do.par=FALSE, type2="contour", caption=caption, col.response=3, func=test1, col.func=4, level=.95, trace=Trace)

 grid:    x         z
  0.4878107 0.5185988

> plotmo(a, do.par=FALSE, degree1=F, degree2=1, type2="image", col.image=topo.colors(10),
+         ylim=NA, level=.95, trace=Trace, main="topo.colors")
> plot(a, select=1)
> plot(a, select=2)
> plot(a, select=3)
> 
> # TODO Following commented out because it no longer works.  Following message from predict:
> #     Error in gam.lo(data[["lo(Wind, Temp)"]], z, w, span = 0.5, degree = 1,  :
> #         NA/NaN/Inf in foreign function call (arg 6)
> # detach("package:mgcv")
> # library(gam)
> # set.seed(1)
> # caption <- "test level=.95, gam:gam(Ozone^(1/3)~lo(Solar.R)+lo(Wind, Temp),data=airquality)"
> # dopar(3,2,caption)
> # data(airquality)
> # airquality <- na.omit(airquality)   # plotmo doesn't know how to deal with NAs yet
> # a <- gam(Ozone^(1/3) ~ lo(Solar.R) + lo(Wind, Temp), data = airquality)
> # cat("Ignore three warnings: No standard errors (currently) for gam predictions with newdata\n")
> # plotmo(a, do.par=FALSE, caption=caption, ylim=NA, col.response=3, level=.95, trace=Trace)
> # # termplot(a)  #TODO this fails with R2.5: dim(data) <- dim: attempt to set an attribute on NULL
> # detach("package:gam")
> 
> # test factors by changing wind to a factor
> 
> ozone2 <- ozone1
> ozone2[,"wind"] <- factor(ozone2[,"wind"], labels=c(
+     "wind0", "wind2", "wind3", "wind4", "wind5", "wind6",
+     "wind7", "wind8", "wind9", "wind10", "wind11"))
> 
> # commented out because factors are not yet supported by plotmo.earth
> # caption <- "test wind=factor, earth(O3 ~ ., data=ozone2)"
> # a <- earth(doy ~ ., data=ozone2)
> # set.seed(1)
> # dopar(4,3,caption)
> # plotmo(a, col.response="gray", level=.95, nrug=-1, do.par=FALSE, caption=caption, trace=Trace)
> # termplot(a)
> 
> caption <- "test wind=factor, lm(doy ~ vh + wind + I(humidity*temp) + log(ibh), data=ozone2)"
> a <- lm(doy ~ vh + wind + I(humidity*temp) + log(ibh), data=ozone2)
> set.seed(1)
> dopar(4,3,caption)
                              test wind=factor, lm(doy ~ vh + wind + I(humidity*temp) + log(ibh), data=ozone2) 
> plotmo(a, col.response="gray", level=.95, nrug=-1, do.par=FALSE, caption=caption, trace=Trace, col.smooth="indianred")

 grid:    vh  wind humidity temp    ibh
        5760 wind0       64   62 2112.5

> termplot(a, se=2)
> 
> caption <- "test level options"
> dopar(2,2,caption)
                              test level options 
> plotmo(a, do.par=FALSE, degree1=2, degree2=FALSE, level=.95, shade.pints=0, caption=caption, trace=Trace)

 grid:    vh  wind humidity temp    ibh
        5760 wind0       64   62 2112.5

> plotmo(a, do.par=FALSE, degree1=2, degree2=FALSE, level=.95, shade.pints="pink", trace=Trace)

 grid:    vh  wind humidity temp    ibh
        5760 wind0       64   62 2112.5

> plotmo(a, do.par=FALSE, degree1=2, degree2=FALSE, level=.95, shade2.pints=0, trace=Trace)

 grid:    vh  wind humidity temp    ibh
        5760 wind0       64   62 2112.5

> 
> caption <- "test wind=factor, glm(y ~ i + j, family=poisson())"
> y <- c(18,17,15,20,10,20,25,13,12)
> i <- gl(3,1,9)
> j <- gl(3,3)
> a <- glm(y ~ i + j, family=poisson())
> set.seed(1)
> dopar(2,2,caption)
                              test wind=factor, glm(y ~ i + j, family=poisson()) 
> plotmo(a, do.par=F, level=.95, nrug=-1, caption=caption, trace=Trace)
Warning: the level argument may not be properly supported on this object built with weights
Warning: the level argument may not be properly supported on this object built with weights

 grid:    i j
          1 1

> termplot(a, se=1, rug=T)
> 
> if(length(grep("package:gam", search())))
+    detach("package:gam")
> caption <- "test wind=factor, gam(doy ~ vh + wind + s(humidity) + s(vh) + temp, data=ozone2)"
> library(mgcv)
> a <- gam(doy ~ vh + wind + s(humidity) + s(vh) + temp, data=ozone2)
> plotmo(a, level=.95, caption=caption, trace=Trace)

 grid:    vh  wind humidity temp
        5760 wind0       64   62

> caption <- "test wind=factor, clip=TRUE, gam(doy ~ vh + wind + s(humidity) + s(vh) + temp, data=ozone2)"
> plotmo(a, level=.95, caption=caption, clip=FALSE, trace=Trace)

 grid:    vh  wind humidity temp
        5760 wind0       64   62

> # termplot doesn't work here so code commented out
> # dopar(3,3,caption)
> # plotmo(a, do.par=FALSE, trace=Trace)
> # termplot(a)
> 
> # commented out because se is not supported for gam::predict.gam
> # detach("package:mgcv")
> # library(gam)
> # caption <- "test wind=factor, gam:gam(doy ~ vh + wind + lo(humidity) + lo(vh) + temp, data=ozone2)"
> # a <- gam(doy ~ vh + wind + lo(humidity) + lo(vh) + temp, data=ozone2)
> # set.seed(1)
> # dopar(4,3,caption)
> # plotmo(a, do.par=FALSE, caption=caption, ylim=NA, col.response=3, level=.95, subcaption=caption, trace=Trace)
> # termplot(a, se=1)
> # detach("package:gam")
> 
> # test lda and qda, and also col.response, pch.response, and jitter.response
> library(MASS)
> etitanic2 <- etitanic
> etitanic2$pclass <- as.numeric(etitanic$pclass)
> etitanic2$sex <- as.numeric(etitanic$sex)
> etitanic2$sibsp <- NULL
> etitanic2$parch <- NULL
> lda.model <- lda(survived ~ ., data=etitanic2)
> expect.err(try(plotmo(lda.model, type="posterior"))) # predicted response has multiple columns ...

 grid:    pclass sex age
               2   2  28


predict.lda(xgrid, type="posterior") returned [3,2]:
          0          1
1 0.5689119 0.43108806
2 0.8135813 0.18641868
3 0.9352020 0.06479797

Error : predicted response has multiple columns (see above) but nresponse is not specified.
       Specify a column index like nresponse=1 or a column name like nresponse="0"
Got error as expected
> set.seed(7)
> plotmo(lda.model, caption="lda", trace=2, clip=F,
+        col.response=as.numeric(etitanic2$survived)+2, type="posterior", nresponse=1, col.smooth="indianred",
+        all2=TRUE, type2="image")
Using env attr(object$terms, ".Environment")

--get.plotmo.x for lda object

formula survived ~ .
stripped formula survived~.
get.data.for.formula: using x from "etitanic2" passed to lda 
about to eval model.frame(formula=survived~., data=structure(list(pclass=c(1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...
got x with colnames from object$call$formula

x[1046,3]:
     pclass sex     age
1         1   1 29.0000
2         1   2  0.9167
3         1   1  2.0000
...       1   2 30.0000
1309      3   2 29.0000

nlevels: pclass=3 sex=2 age=98 

--get.plotmo.y for lda object

formula survived ~ .
stripped formula survived~.
get.data.for.formula: using y from "etitanic2" passed to lda 
about to eval model.frame(formula=survived~., data=structure(list(pclass=c(1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...
got y from object$call$formula
get.plotmo.y returned length 1046 min 0 max 1
             value 1 1 0 0 0 1 1 0 1 0 ...

--get.plotmo.singles for lda object

singles: 1 pclass, 2 sex, 3 age 

--get.plotmo.pairs for lda object

pairs:
     [,1]       [,2]   
[1,] "1 pclass" "2 sex"
[2,] "1 pclass" "3 age"
[3,] "2 sex"    "3 age"

ylim 0 1 

--plot.degree1(draw.plot=TRUE)

 grid:    pclass sex age
               2   2  28


plotmo.predict(type="posterior") for degree1 plot "pclass" with newdata[3,3]:
  pclass sex age
1      1   2  28
2      2   2  28
3      3   2  28

predict.lda(xgrid, type="posterior") column "0" returned length 3 min 0.5689119 max 0.935202
                                     value 0.5689119 0.8135813 0.935202 

plotmo.predict(type="posterior") for degree1 plot "sex" with newdata[2,3]:
  pclass sex age
1      2   1  28
2      2   2  28

predict.lda(xgrid, type="posterior") column "0" returned length 2 min 0.1489949 max 0.8135813
                                     value 0.1489949 0.8135813 

plotmo.predict(type="posterior") for degree1 plot "age" with newdata[50,3]:
    pclass sex       age
1        2   2  0.166700
2        2   2  1.795951
3        2   2  3.425202
...      2   2  5.054453
50       2   2 80.000000

predict.lda(xgrid, type="posterior") column "0" returned length 50 min 0.6286389 max 0.9624145
                                     value 0.6286389 0.641486 0.6541332 0.6665662 0.6787717 0.6907377 0.7024534 0.713909 0.7250962 0.7360078 ...

--plot.degree2(draw.plot=TRUE)

plotmo.predict(type="posterior") for degree2 plot "pclass:sex" with newdata[6,3]:
    pclass sex age
1        1   1  28
2        2   1  28
3        3   1  28
...      1   2  28
3.1      3   2  28

predict.lda(xgrid, type="posterior") column "0" returned length 6 min 0.05028077 max 0.935202
                                     value 0.05028077 0.1489949 0.3666841 0.5689119 0.8135813 0.935202 

plotmo.predict(type="posterior") for degree2 plot "pclass:age" with newdata[60,3]:
    pclass sex       age
1        1   2  0.166700
2        2   2  0.166700
3        3   2  0.166700
...      1   2  4.368453
60       3   2 80.000000

predict.lda(xgrid, type="posterior") column "0" returned length 60 min 0.338574 max 0.9883285
                                     value 0.338574 0.6286389 0.8484402 0.3712905 0.6613582 0.865924 0.4052315 0.6926044 0.8816722 0.4401032 ...

plotmo.predict(type="posterior") for degree2 plot "sex:age" with newdata[40,3]:
    pclass sex       age
1        2   1  0.166700
2        2   2  0.166700
3        2   1  4.368453
...      2   2  4.368453
40       2   2 80.000000

predict.lda(xgrid, type="posterior") column "0" returned length 40 min 0.06359133 max 0.9624145
                                     value 0.06359133 0.6286389 0.07265495 0.6613582 0.08289605 0.6926044 0.09443369 0.7221787 0.1073891 0.7499349 ...
> set.seed(8)
> plotmo(lda.model, caption="lda with jitter", trace=2, clip=F,
+        col.response=as.numeric(etitanic2$survived)+2, type="posterior", nresponse=1,
+        all2=TRUE, type2="image", jitter.response=.3)
Using env attr(object$terms, ".Environment")

--get.plotmo.x for lda object

formula survived ~ .
stripped formula survived~.
get.data.for.formula: using x from "etitanic2" passed to lda 
about to eval model.frame(formula=survived~., data=structure(list(pclass=c(1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...
got x with colnames from object$call$formula

x[1046,3]:
     pclass sex     age
1         1   1 29.0000
2         1   2  0.9167
3         1   1  2.0000
...       1   2 30.0000
1309      3   2 29.0000

nlevels: pclass=3 sex=2 age=98 

--get.plotmo.y for lda object

formula survived ~ .
stripped formula survived~.
get.data.for.formula: using y from "etitanic2" passed to lda 
about to eval model.frame(formula=survived~., data=structure(list(pclass=c(1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...
got y from object$call$formula
get.plotmo.y returned length 1046 min 0 max 1
             value 1 1 0 0 0 1 1 0 1 0 ...

--get.plotmo.singles for lda object

singles: 1 pclass, 2 sex, 3 age 

--get.plotmo.pairs for lda object

pairs:
     [,1]       [,2]   
[1,] "1 pclass" "2 sex"
[2,] "1 pclass" "3 age"
[3,] "2 sex"    "3 age"

ylim 0 1 

--plot.degree1(draw.plot=TRUE)

 grid:    pclass sex age
               2   2  28


plotmo.predict(type="posterior") for degree1 plot "pclass" with newdata[3,3]:
  pclass sex age
1      1   2  28
2      2   2  28
3      3   2  28

predict.lda(xgrid, type="posterior") column "0" returned length 3 min 0.5689119 max 0.935202
                                     value 0.5689119 0.8135813 0.935202 

plotmo.predict(type="posterior") for degree1 plot "sex" with newdata[2,3]:
  pclass sex age
1      2   1  28
2      2   2  28

predict.lda(xgrid, type="posterior") column "0" returned length 2 min 0.1489949 max 0.8135813
                                     value 0.1489949 0.8135813 

plotmo.predict(type="posterior") for degree1 plot "age" with newdata[50,3]:
    pclass sex       age
1        2   2  0.166700
2        2   2  1.795951
3        2   2  3.425202
...      2   2  5.054453
50       2   2 80.000000

predict.lda(xgrid, type="posterior") column "0" returned length 50 min 0.6286389 max 0.9624145
                                     value 0.6286389 0.641486 0.6541332 0.6665662 0.6787717 0.6907377 0.7024534 0.713909 0.7250962 0.7360078 ...

--plot.degree2(draw.plot=TRUE)

plotmo.predict(type="posterior") for degree2 plot "pclass:sex" with newdata[6,3]:
    pclass sex age
1        1   1  28
2        2   1  28
3        3   1  28
...      1   2  28
3.1      3   2  28

predict.lda(xgrid, type="posterior") column "0" returned length 6 min 0.05028077 max 0.935202
                                     value 0.05028077 0.1489949 0.3666841 0.5689119 0.8135813 0.935202 

plotmo.predict(type="posterior") for degree2 plot "pclass:age" with newdata[60,3]:
    pclass sex       age
1        1   2  0.166700
2        2   2  0.166700
3        3   2  0.166700
...      1   2  4.368453
60       3   2 80.000000

predict.lda(xgrid, type="posterior") column "0" returned length 60 min 0.338574 max 0.9883285
                                     value 0.338574 0.6286389 0.8484402 0.3712905 0.6613582 0.865924 0.4052315 0.6926044 0.8816722 0.4401032 ...

plotmo.predict(type="posterior") for degree2 plot "sex:age" with newdata[40,3]:
    pclass sex       age
1        2   1  0.166700
2        2   2  0.166700
3        2   1  4.368453
...      2   2  4.368453
40       2   2 80.000000

predict.lda(xgrid, type="posterior") column "0" returned length 40 min 0.06359133 max 0.9624145
                                     value 0.06359133 0.6286389 0.07265495 0.6613582 0.08289605 0.6926044 0.09443369 0.7221787 0.1073891 0.7499349 ...
> qda.model <- qda(survived ~ ., data=etitanic2)
> set.seed(9)
> plotmo(qda.model, caption="qda with jitter", trace=2, clip=F,
+        col.response=as.numeric(etitanic2$survived)+2, type="post", nresponse=2, col.smooth="indianred",
+        all2=TRUE, type2="image", jitter.resp=.6, pch.resp=20)
Using env attr(object$terms, ".Environment")

--get.plotmo.x for qda object

formula survived ~ .
stripped formula survived~.
get.data.for.formula: using x from "etitanic2" passed to qda 
about to eval model.frame(formula=survived~., data=structure(list(pclass=c(1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...
got x with colnames from object$call$formula

x[1046,3]:
     pclass sex     age
1         1   1 29.0000
2         1   2  0.9167
3         1   1  2.0000
...       1   2 30.0000
1309      3   2 29.0000

nlevels: pclass=3 sex=2 age=98 

--get.plotmo.y for qda object

formula survived ~ .
stripped formula survived~.
get.data.for.formula: using y from "etitanic2" passed to qda 
about to eval model.frame(formula=survived~., data=structure(list(pclass=c(1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...
got y from object$call$formula
get.plotmo.y returned length 1046 min 0 max 1
             value 1 1 0 0 0 1 1 0 1 0 ...

--get.plotmo.singles for qda object

singles: 1 pclass, 2 sex, 3 age 

--get.plotmo.pairs for qda object

pairs:
     [,1]       [,2]   
[1,] "1 pclass" "2 sex"
[2,] "1 pclass" "3 age"
[3,] "2 sex"    "3 age"

ylim 0 1 

--plot.degree1(draw.plot=TRUE)

 grid:    pclass sex age
               2   2  28


plotmo.predict(type="post") for degree1 plot "pclass" with newdata[3,3]:
  pclass sex age
1      1   2  28
2      2   2  28
3      3   2  28

predict.qda(xgrid, type="post") column "1" returned length 3 min 0.09172236 max 0.4136036
                                value 0.4136036 0.173235 0.09172236 

plotmo.predict(type="post") for degree1 plot "sex" with newdata[2,3]:
  pclass sex age
1      2   1  28
2      2   2  28

predict.qda(xgrid, type="post") column "1" returned length 2 min 0.173235 max 0.9020997
                                value 0.9020997 0.173235 

plotmo.predict(type="post") for degree1 plot "age" with newdata[50,3]:
    pclass sex       age
1        2   2  0.166700
2        2   2  1.795951
3        2   2  3.425202
...      2   2  5.054453
50       2   2 80.000000

predict.qda(xgrid, type="post") column "1" returned length 50 min 0.0727541 max 0.5382786
                                value 0.5382786 0.5073867 0.4771642 0.4478275 0.419558 0.3925005 0.3667628 0.3424184 0.3195085 0.2980465 ...

--plot.degree2(draw.plot=TRUE)

plotmo.predict(type="post") for degree2 plot "pclass:sex" with newdata[6,3]:
    pclass sex age
1        1   1  28
2        2   1  28
3        3   1  28
...      1   2  28
3.1      3   2  28

predict.qda(xgrid, type="post") column "1" returned length 6 min 0.09172236 max 0.9868176
                                value 0.9868176 0.9020997 0.6479004 0.4136036 0.173235 0.09172236 

plotmo.predict(type="post") for degree2 plot "pclass:age" with newdata[60,3]:
    pclass sex       age
1        1   2  0.166700
2        2   2  0.166700
3        3   2  0.166700
...      1   2  4.368453
60       3   2 80.000000

predict.qda(xgrid, type="post") column "1" returned length 60 min 0.0536493 max 0.8412456
                                value 0.8412456 0.5382786 0.293836 0.7872905 0.4600594 0.2414025 0.7249536 0.3883466 0.1987967 0.6567895 ...

plotmo.predict(type="post") for degree2 plot "sex:age" with newdata[40,3]:
    pclass sex       age
1        2   1  0.166700
2        2   2  0.166700
3        2   1  4.368453
...      2   2  4.368453
40       2   2 80.000000

predict.qda(xgrid, type="post") column "1" returned length 40 min 0.07281274 max 0.9627743
                                value 0.9627743 0.5382786 0.9544618 0.4600594 0.9454079 0.3883466 0.9358487 0.3253971 0.9260848 0.271993 ...
> 
> # test get.plotmo.y from the 2nd argument of the model function (non-formula interface)
> lcush <- data.frame(Type=as.numeric(Cushings$Type), log(Cushings[,1:2]))[1:21,]
> a <- qda(lcush[,2:3], lcush[,1])
> plotmo(a, type="class", all2=TRUE, trace=1,
+        caption= "get.plotmo.y from 2nd argument of call (qda)",
+        type2="contour", ngrid2=100, nlevels=2, drawlabels=FALSE,
+        col.response=as.numeric(lcush$Type)+1,
+        pch.response=as.character(lcush$Type))
Using env parent.frame()

--get.plotmo.x for qda object

got x with colnames from object$call$x

x[21,2]:
    Tetrahydrocortisone Pregnanetriol
a1            1.1314021     2.4595888
a2            1.0986123     0.2623643
a3            0.6418539    -2.3025851
...           1.3350011    -3.2188758
c5            2.7600099     2.0281482

nlevels: Tetrahydrocortisone=19 Pregnanetriol=17 

--get.plotmo.y for qda object

got y from the second argument to the model function
get.plotmo.y returned length 21 min 1 max 3
             value 1 1 1 1 1 1 2 2 2 2 ...

clip.limits -Inf Inf 

--plot.degree1(draw.plot=FALSE)

plotmo.predict(type="class") for degree1 plot "Tetrahydrocortisone" with newdata[19,2]:
    Tetrahydrocortisone Pregnanetriol
1             0.6418539     0.1823216
2             1.0986123     0.1823216
3             1.1314021     0.1823216
...           1.3350011     0.1823216
19            3.9852735     0.1823216

predict.qda(xgrid, type="class") returned length 19 min 1 max 3
                                 value 1 1 1 1 1 1 2 2 2 2 ...

--plot.degree2(draw.plot=FALSE)

plotmo.predict(type="class") for degree2 plot "Tetrahydrocortisone:Pregnanetriol" with newdata[323,2]:
      Tetrahydrocortisone Pregnanetriol
1               0.6418539     -3.218876
2               1.0986123     -3.218876
3               1.1314021     -3.218876
...             1.3350011     -3.218876
19.16           3.9852735      2.459589

predict.qda(xgrid, type="class") returned length 323 min 1 max 3
                                 value 1 1 1 1 1 1 1 1 1 1 ...

ylim 1 3 

 grid:    Tetrahydrocortisone Pregnanetriol
                      2.04122     0.1823216

> 
> # # example from MASS (works, but removed because unnecessary test)
> # predplot <- function(object, main="", len = 100, ...)
> # {
> #     plot(Cushings[,1], Cushings[,2], log="xy", type="n",
> #          xlab = "Tetrahydrocortisone", ylab = "Pregnanetriol", main = main)
> #     for(il in 1:4) {
> #         set <- Cushings$Type==levels(Cushings$Type)[il]
> #         text(Cushings[set, 1], Cushings[set, 2],
> #              labels=as.character(Cushings$Type[set]), col = 2 + il) }
> #     xp <- seq(0.6, 4.0, length=len)
> #     yp <- seq(-3.25, 2.45, length=len)
> #     cushT <- expand.grid(Tetrahydrocortisone = xp,
> #                          Pregnanetriol = yp)
> #     Z <- predict(object, cushT, ...); zp <- as.numeric(Z$class)
> #     zp <- Z$post[,3] - pmax(Z$post[,2], Z$post[,1])
> #     contour(exp(xp), exp(yp), matrix(zp, len),
> #             add = TRUE, levels = 0, labex = 0)
> #     zp <- Z$post[,1] - pmax(Z$post[,2], Z$post[,3])
> #     contour(exp(xp), exp(yp), matrix(zp, len),
> #             add = TRUE, levels = 0, labex = 0)
> #     invisible()
> # }
> # par(mfrow=c(2,2))
> # cush <- log(as.matrix(Cushings[, -3]))
> # tp <- Cushings$Type[1:21, drop = TRUE]
> # set.seed(203)
> # cush.data <- data.frame(tp, cush[1:21,])
> # a <- qda(tp~., data=cush.data)
> # predplot(a, "QDA example from MASS")
> # plotmo(a, type="class", all2=TRUE, type2="contour", degree1=NA, do.par=FALSE,
> #        col.response=as.numeric(cush.data$tp)+1)
> # plotmo(a, type="class", all2=TRUE, type2="contour", degree1=NA, do.par=FALSE,
> #        col.response=as.numeric(cush.data$tp)+1, drawlabels=F, nlevels=2)
> # plotmo(a, type="class", all2=TRUE, type2="contour", degree1=NA, do.par=FALSE,
> #        col.response=as.numeric(cush.data$tp)+1, drawlabels=F, nlevels=2, ngrid2=100)
> # par(mfrow=c(1,1))
> 
> library(rpart.plot)
Loading required package: rpart

Attaching package: 'rpart'

The following object is masked from 'package:faraway':

    solder

> data(kyphosis)
> # kyphosis data, earth model
> a <- earth(Kyphosis ~ ., data=kyphosis, degree=2, glm=list(family=binomial))
> par(mfrow=c(3, 3))
> old.mar <- par(mar=c(3, 3, 2, .5))  # small margins to pack figs in
> set.seed(9) # for jitter
> plotmo(a, do.par=F, type2="image",
+        col.response=ifelse(kyphosis$Kyphosis=="present", "red", "lightblue"),
+        clip=F, jitter=.5)

 grid:    Age Number Start
           87      4    13

> plotmo(a, do.par=F, clip=F, degree1=0)
> par(mar=old.mar)
> 
> # kyphosis data, rpart models (also test ngrid2)
> fit1 <- rpart(Kyphosis ~ ., data=kyphosis)
> par(mfrow=c(3, 3))
> old.par <- par(mar=c(.5, 0.5, 2, .5), mgp = c(1.6, 0.6, 0))  # b l t r small margins to pack figs in
> prp(fit1, main="rpart kyphosis\nno prior")
> plotmo(fit1, degree1=NA, do.par=F, main="", theta=220, expand=.5, nresponse=2)
> par(mar=c(4, 4, 2, .5))
> plotmo(fit1, nresp=2, degree1=FALSE, do.par=F, main="", type2="image", # test default type="prob"
+        col.response=ifelse(kyphosis$Kyphosis=="present", "red", "lightblue"),
+        pch.response=ifelse(kyphosis$Kyphosis=="present", "p", "a"),
+        col.image=gray(10:4/10), ngrid2=30)
> par(mar=c(.5, 0.5, 2, .5))  # b l t r small margins to pack figs in
> plotmo(fit1, type="class", degree1=NA, do.par=F, main="type=\"class\"", expand=.5)
> plotmo(fit1, type="prob", nresp=2, degree1=0, do.par=F, main="type=\"prob\"",
+        expand=.5, clip=F, ngrid2=50, border=NA)
> plotmo(fit1, type="prob", nresp=2, degree1=NA, do.par=F, main="", type2="image",
+        col.response=ifelse(kyphosis$Kyphosis=="present", "red", "lightblue"),
+        pch.response=20, col.image=gray(10:4/10), ngrid2=5)
> # better rpart model with prior
> fit2 <- rpart(Kyphosis ~ ., data=kyphosis, parms=list(prior=c(.65,.35)))
> prp(fit2, main="rpart kyphosis\nwith prior, better model")
> plotmo(fit2, type="v", degree1=NA, do.par=F, main="", expand=.5, theta=220, ngrid2=10)
> par(mar=c(4, 4, 2, .5))
> plotmo(fit2, type="v", degree1=NA, do.par=F, main="", type2="image",
+        col.response=ifelse(kyphosis$Kyphosis=="present", "red", "lightblue"),
+        pch.response=20, col.image=gray(10:4/10), ngrid2=100)
> par(mar=old.par$mar, mgp=old.par$mgp)
> 
> plotmo(fit1, type="prob", nresponse=1, border=NA, col.persp="pink", all1=TRUE, all2=TRUE,
+        caption="plotmo rpart fit1, all1=TRUE, all2=TRUE")

 grid:    Age Number Start
           87      4    13

> expect.err(try(plotmo(fit1, type="none.such1")))
Error : predict.rpart does not support type="none.such1"
Got error as expected
> 
> # rpart model with ozone data
> data(ozone1)
> par(mfrow=c(4,4))
> old.par <- par(mar=c(.5, 0.5, 2, .5), cex=.6, mgp = c(1.6, 0.6, 0))  # b l t r small margins to pack figs in
> a1 <- rpart(O3~temp+humidity, data=ozone1)
> prp(a1, main="rpart model with ozone data\n(temp and humidity only)\n")
> plotmo(a1, do.par=F, degree1=0, main="rpart", ticktype="detail", nticks=2, expand=.7)
> expect.err(try(plotmo(a1, type="class")))
Error : predict.rpart does not support type="class" (for "anova" rpart objects)
Got error as expected
> # compare to a linear and earth model
> a3 <- lm(O3~temp+humidity, data=ozone1)
> plotmo(a3, do.par=F, clip=F, main="lm", degree1=0, all2=TRUE, ticktype="detail", nticks=2, expand=.7)
> expect.err(try(plotmo(a3, type="none.such2")))
Error in match.arg(type) : 'arg' should be one of "response", "terms"
Got error as expected
> a <- earth(O3~temp+humidity, data=ozone1, degree=2)
> plotmo(a, do.par=F, clip=F, main="earth", degree1=NA, ticktype="detail", nticks=2, expand=.7)
> expect.err(try(plotmo(a, type="none.such3")))
Error : type="none.such3" is not allowed.
Choose one of: "link" "response" "earth" "class" "terms"
Got error as expected
> expect.err(try(plotmo(a, type=c("abc", "def"))))
Error : length(type) == 1 is not TRUE
Got error as expected
> 
> # detailed rpart model
> par(mfrow=c(3,3))
> a1 <- rpart(O3~., data=ozone1)
> prp(a1, cex=.9, main="rpart model with full ozone data")
> plotmo(a1, type="vector", do.par=F, degree1=NA, ticktype="detail",
+        nticks=3, expand=.7, degree2=2:3)
> par(mar=old.par$mar, cex=old.par$cex, mgp=old.par$mgp)
> 
> plotmo(a1, border=NA, all1=TRUE, all2=TRUE,
+        caption="plotmo rpart a1, all1=TRUE, all2=TRUE")

 grid:    vh wind humidity temp    ibh dpg   ibt vis   doy
        5760    5       64   62 2112.5  24 167.5 120 205.5

> 
> # test xflip and yflip
> 
> par(mfrow=c(4, 4))
> par(mgp = c(1.6, 0.6, 0))
> par(mar=c(4, 4, 2, .5))
> 
> flip.test1 <- rpart(Kyphosis ~ ., data=kyphosis)
> plotmo(flip.test1, type="prob", nresp=2, degree1=NA, do.par=F, main="", type2="image",
+        col.response=ifelse(kyphosis$Kyphosis=="present", "red", "lightblue"),
+        pch.response=20, col.image=gray(10:4/10))
> plotmo(flip.test1, type="prob", nresp=2, degree1=NA, do.par=F, main="xflip", type2="image",
+        col.response=ifelse(kyphosis$Kyphosis=="present", "red", "lightblue"),
+        pch.response=20, col.image=gray(10:4/10),
+        xflip=T)
> plotmo(flip.test1, type="prob", nresp=2, degree1=NA, do.par=F, main="yflip", type2="image",
+        col.response=ifelse(kyphosis$Kyphosis=="present", "red", "lightblue"),
+        pch.response=20, col.image=gray(10:4/10),
+        yflip=T)
> plotmo(flip.test1, type="prob", nresp=2, degree1=NA, do.par=F, main="xflip and yflip", type2="image",
+        col.response=ifelse(kyphosis$Kyphosis=="present", "red", "lightblue"),
+        pch.response=20, col.image=gray(10:4/10),
+        xflip=T, yflip=T)
> 
> flip.test2 <- earth(O3~., data=ozone1, degree=2)
> plotmo(flip.test2, degree1=NA, degree2=2, do.par=F, main="", type2="cont")
> plotmo(flip.test2, degree1=NA, degree2=2, do.par=F, main="xflip", type2="cont",
+        xflip=T)
> plotmo(flip.test2, degree1=NA, degree2=2, do.par=F, main="yflip", type2="cont",
+        yflip=T)
> plotmo(flip.test2, degree1=NA, degree2=2, do.par=F, main="xflip and yflip", type2="cont",
+        xflip=T, yflip=T)
> 
> cat("Expect warnings: ignoring xflip=TRUE for persp plot\n")
Expect warnings: ignoring xflip=TRUE for persp plot
> plotmo(flip.test2, degree1=NA, degree2=2, do.par=F, main="xflip and yflip", type2="persp",
+        xflip=T, yflip=T)
Warning: ignoring xflip=TRUE for persp plot
Warning: ignoring yflip=TRUE for persp plot
> 
> library(randomForest)
randomForest 4.6-10
Type rfNews() to see new features/changes/bug fixes.
> data(ozone1)
> set.seed(3)
> a <- randomForest(O3~., data=ozone1, ntree=5)
> plotmo(a, caption="randomForest ozone1")

 grid:    vh wind humidity temp    ibh dpg   ibt vis   doy
        5760    5       64   62 2112.5  24 167.5 120 205.5

> set.seed(4)
> a <- randomForest(Kyphosis ~ ., data=kyphosis, ntree=5, mtry=2)
> plotmo(a, type="prob", trace=0, nresponse="pre", caption="randomForest kyphosis", ndiscrete=10)

 grid:    Age Number Start
           87      4    13

> 
> # gbm
> library(gbm)
Loading required package: survival
Loading required package: splines

Attaching package: 'survival'

The following object is masked from 'package:faraway':

    rats

Loading required package: lattice

Attaching package: 'lattice'

The following object is masked from 'package:faraway':

    melanoma

Loading required package: parallel
Loaded gbm 2.1
> library(rpart.plot) # for ptitanic, want data with NAs for testing
> data(ptitanic)
> ptit <- ptitanic[c(1:10,400:410,600:610),] # small data for fast test
> ptit <- ptitanic
> ptit$survived <- ptit$survived == "survived"
> temp <- ptit$pclass # put pclass at the end so can check ordering of importances
> ptit$pclass <- NULL
> ptit$pclass <- factor(as.numeric(temp), labels=c("first", "second", "third"))
> set.seed(1010)
> gbm.model <- gbm(survived~., data=ptit, train.frac=.95, verbose=TRUE,
+                  n.trees=30, shrinkage=.1) # small number of trees for fast test
Distribution not specified, assuming bernoulli ...
Iter   TrainDeviance   ValidDeviance   StepSize   Improve
     1        1.2866          1.1075     0.1000    0.0267
     2        1.2462          1.0707     0.1000    0.0211
     3        1.2135          1.0380     0.1000    0.0173
     4        1.1838          1.0051     0.1000    0.0136
     5        1.1615          0.9809     0.1000    0.0113
     6        1.1451          0.9631     0.1000    0.0091
     7        1.1278          0.9437     0.1000    0.0076
     8        1.1135          0.9229     0.1000    0.0059
     9        1.1010          0.9032     0.1000    0.0061
    10        1.0903          0.8884     0.1000    0.0048
    20        1.0179          0.7965     0.1000    0.0020
    30        0.9866          0.7623     0.1000    0.0007

> par(mfrow=c(3,4))
> par(mar=c(3.5, 3, 2, 0.5))  # small margins and text to pack figs in
> par(mgp=c(1.5, .5, 0))      # flatten axis elements
> plotmo(gbm.model, trace=0, ticktype="d", nticks=2, do.par=F,
+        degree1=0, degree2=3, main="gbm model")
> plotmo(gbm.model, trace=0, type2="im", do.par=F,
+        col.response=ptit$survived+2, pch.response=20, jitter=.3, cex.response=.5)

 grid:    sex age sibsp parch pclass
       female  28     0     0  first

> print(summary(gbm.model))   # will also plot
          var   rel.inf
sex       sex 76.528849
pclass pclass 18.525225
age       age  3.353178
sibsp   sibsp  1.592748
parch   parch  0.000000
> par(mfrow=c(1,1))
> 
> library(caret)
Loading required package: ggplot2

Attaching package: 'caret'

The following object is masked from 'package:survival':

    cluster

> set.seed(13)
> a.bag1 <- bagEarth(trees[,-3], trees[,3], B = 3)
> plotmo(a.bag1, all2=TRUE, caption="bagEarth, trees")

 grid:    Girth Height
           12.9     76

> set.seed(14)
> a.bag2 <- bagEarth(O3~., data=ozone1, degree=2, B=3)
> plotmo(a.bag2, degree1=c(4, 7), degree2=1:2, clip=F, caption="bagEarth, ozone1")

 grid:    vh wind humidity temp    ibh dpg   ibt vis   doy
        5760    5       64   62 2112.5  24 167.5 120 205.5

> # # TODO following doesn't work properly, factors are plotted as continuous
> # a.bag3 <- bagEarth(survived~., data=etitanic, degree=2, B=3)
> # plotmo(a.bag3, clip=F, caption="bagEarth, etitanic")
> 
> library(nnet)
> data(iris3)
> set.seed(301)
> samp <- c(sample(1:50,25), sample(51:100,25), sample(101:150,25))
> ird <- data.frame(rbind(iris3[,,1], iris3[,,2], iris3[,,3]),
+                   species=factor(c(rep("seto",50), rep("vers", 50), rep("virg", 50))))
> ir.nn2 <- nnet(species ~ ., data = ird, subset = samp, size = 2, rang = 0.1,
+                decay = 5e-4, maxit = 20, trace=F)
> plotmo(ir.nn2, type="class", trace=2, all2=T, degree2=2:6)
Using env attr(object$terms, ".Environment")

--get.plotmo.x for nnet.formula object

formula species ~ .
stripped formula species~.
get.data.for.formula: using x from "ird" passed to nnet.formula 
about to eval model.frame(formula=species~., data=structure(list(Sepal.L.=c(5.1, 
    4.9, 4.7, 4.6, 5, 5.4, 4.6, 5, 4.4, 4.9, 5.4, 4.8, 4.8, 4.3, 
    5.8, 5.7, 5.4, 5.1, 5.7, 5.1, 5.4, 5.1, 4.6, 5.1, 4.8, 5, 5, 
    5.2, 5.2, 4.7, 4.8, 5.4, 5.2, 5.5, 4.9, 5, 5.5, 4.9, 4.4, 5.1, 
    5, 4.5, 4.4, 5, 5.1, 4.8, 5.1, 4.6, 5.3, 5, 7, 6.4, 6.9, 5.5, 
    6.5, 5.7, 6.3, 4.9, 6.6, 5.2, 5, 5.9, 6, 6.1, 5.6, 6.7, 5.6, 
    5.8, 6.2, 5.6, 5.9, 6.1, 6.3, 6.1, 6.4, 6.6, 6.8, 6.7, 6, 5.7, 
    5.5, 5.5, 5.8, 6, 5.4, 6, 6.7, 6.3, 5.6, 5.5, 5.5, 6.1, 5.8, ...
got x with colnames from object$call$formula
got subset from object$call$subset length 75 min 1 max 147
                value 30 7 1 36 29 20 50 43 19 35 ...

x[75,4] (after taking subset):
    Sepal.L. Sepal.W. Petal.L. Petal.W.
30       4.7      3.2      1.6      0.2
7        4.6      3.4      1.4      0.3
1        5.1      3.5      1.4      0.2
...      5.0      3.2      1.2      0.2
147      6.3      2.5      5.0      1.9

nlevels: Sepal.L.=28 Sepal.W.=18 Petal.L.=33 Petal.W.=21 

--get.plotmo.y for nnet.formula object

formula species ~ .
stripped formula species~.
get.data.for.formula: using y from "ird" passed to nnet.formula 
about to eval model.frame(formula=species~., data=structure(list(Sepal.L.=c(5.1, 
    4.9, 4.7, 4.6, 5, 5.4, 4.6, 5, 4.4, 4.9, 5.4, 4.8, 4.8, 4.3, 
    5.8, 5.7, 5.4, 5.1, 5.7, 5.1, 5.4, 5.1, 4.6, 5.1, 4.8, 5, 5, 
    5.2, 5.2, 4.7, 4.8, 5.4, 5.2, 5.5, 4.9, 5, 5.5, 4.9, 4.4, 5.1, 
    5, 4.5, 4.4, 5, 5.1, 4.8, 5.1, 4.6, 5.3, 5, 7, 6.4, 6.9, 5.5, 
    6.5, 5.7, 6.3, 4.9, 6.6, 5.2, 5, 5.9, 6, 6.1, 5.6, 6.7, 5.6, 
    5.8, 6.2, 5.6, 5.9, 6.1, 6.3, 6.1, 6.4, 6.6, 6.8, 6.7, 6, 5.7, 
    5.5, 5.5, 5.8, 6, 5.4, 6, 6.7, 6.3, 5.6, 5.5, 5.5, 6.1, 5.8, ...
got y from object$call$formula
got subset from object$call$subset length 75 min 1 max 147
                value 30 7 1 36 29 20 50 43 19 35 ...
get.plotmo.y returned length 150 (before taking subset) min 1 max 3
             value 1 1 1 1 1 1 1 1 1 1 ...

clip.limits -Inf Inf 

--get.plotmo.singles for nnet.formula object

singles: 1 Sepal.L., 2 Sepal.W., 3 Petal.L., 4 Petal.W. 

--get.plotmo.pairs for nnet.formula object

pairs:
     [,1]         [,2]        
[1,] "1 Sepal.L." "3 Petal.L."
[2,] "1 Sepal.L." "4 Petal.W."
[3,] "2 Sepal.W." "3 Petal.L."
[4,] "2 Sepal.W." "4 Petal.W."
[5,] "3 Petal.L." "4 Petal.W."

--plot.degree1(draw.plot=FALSE)

plotmo.predict(type="class") for degree1 plot "Sepal.L." with newdata[28,4]:
    Sepal.L. Sepal.W. Petal.L. Petal.W.
1        4.4        3      4.4      1.3
2        4.5        3      4.4      1.3
3        4.6        3      4.4      1.3
...      4.7        3      4.4      1.3
28       7.9        3      4.4      1.3

predict.nnet.formula(xgrid, type="class") returned length 28 min 1 max 1
                                          value 1 1 1 1 1 1 1 1 1 1 ...

plotmo.predict(type="class") for degree1 plot "Sepal.W." with newdata[18,4]:
    Sepal.L. Sepal.W. Petal.L. Petal.W.
1        5.8      2.2      4.4      1.3
2        5.8      2.3      4.4      1.3
3        5.8      2.5      4.4      1.3
...      5.8      2.6      4.4      1.3
18       5.8      4.4      4.4      1.3

predict.nnet.formula(xgrid, type="class") returned length 18 min 1 max 3
                                          value 3 2 2 2 2 2 2 2 2 2 ...

plotmo.predict(type="class") for degree1 plot "Petal.L." with newdata[33,4]:
    Sepal.L. Sepal.W. Petal.L. Petal.W.
1        5.8        3      1.0      1.3
2        5.8        3      1.2      1.3
3        5.8        3      1.3      1.3
...      5.8        3      1.4      1.3
33       5.8        3      6.7      1.3

predict.nnet.formula(xgrid, type="class") returned length 33 min 1 max 3
                                          value 1 1 1 1 1 1 1 1 1 2 ...

plotmo.predict(type="class") for degree1 plot "Petal.W." with newdata[21,4]:
    Sepal.L. Sepal.W. Petal.L. Petal.W.
1        5.8        3      4.4      0.1
2        5.8        3      4.4      0.2
3        5.8        3      4.4      0.3
...      5.8        3      4.4      0.4
21       5.8        3      4.4      2.4

predict.nnet.formula(xgrid, type="class") returned length 21 min 1 max 3
                                          value 1 1 1 1 1 1 2 2 2 2 ...

--plot.degree2(draw.plot=FALSE)

plotmo.predict(type="class") for degree2 plot "Sepal.L.:Petal.L." with newdata[400,4]:
    Sepal.L. Sepal.W. Petal.L. Petal.W.
1   4.400000        3      1.0      1.3
2   4.584211        3      1.0      1.3
3   4.768421        3      1.0      1.3
... 4.952632        3      1.0      1.3
400 7.900000        3      6.7      1.3

predict.nnet.formula(xgrid, type="class") returned length 400 min 1 max 3
                                          value 1 1 1 1 1 1 1 1 1 1 ...

plotmo.predict(type="class") for degree2 plot "Sepal.L.:Petal.W." with newdata[400,4]:
    Sepal.L. Sepal.W. Petal.L. Petal.W.
1   4.400000        3      4.4      0.1
2   4.584211        3      4.4      0.1
3   4.768421        3      4.4      0.1
... 4.952632        3      4.4      0.1
400 7.900000        3      4.4      2.4

predict.nnet.formula(xgrid, type="class") returned length 400 min 1 max 3
                                          value 1 1 1 1 1 1 1 1 1 1 ...

plotmo.predict(type="class") for degree2 plot "Sepal.W.:Petal.L." with newdata[360,4]:
    Sepal.L. Sepal.W. Petal.L. Petal.W.
1        5.8      2.2      1.0      1.3
2        5.8      2.3      1.0      1.3
3        5.8      2.5      1.0      1.3
...      5.8      2.6      1.0      1.3
360      5.8      4.4      6.7      1.3

predict.nnet.formula(xgrid, type="class") returned length 360 min 1 max 3
                                          value 1 1 1 1 1 1 1 1 1 1 ...

plotmo.predict(type="class") for degree2 plot "Sepal.W.:Petal.W." with newdata[360,4]:
    Sepal.L. Sepal.W. Petal.L. Petal.W.
1        5.8      2.2      4.4      0.1
2        5.8      2.3      4.4      0.1
3        5.8      2.5      4.4      0.1
...      5.8      2.6      4.4      0.1
360      5.8      4.4      4.4      2.4

predict.nnet.formula(xgrid, type="class") returned length 360 min 1 max 3
                                          value 1 1 1 1 1 1 1 1 1 1 ...

plotmo.predict(type="class") for degree2 plot "Petal.L.:Petal.W." with newdata[400,4]:
    Sepal.L. Sepal.W. Petal.L. Petal.W.
1        5.8        3      1.0      0.1
2        5.8        3      1.3      0.1
3        5.8        3      1.6      0.1
...      5.8        3      1.9      0.1
400      5.8        3      6.7      2.4

predict.nnet.formula(xgrid, type="class") returned length 400 min 1 max 3
                                          value 1 1 1 1 1 1 1 1 1 1 ...


ylim 1 3 

--plot.degree1(draw.plot=TRUE)

 grid:    Sepal.L. Sepal.W. Petal.L. Petal.W.
               5.8        3      4.4      1.3


--plot.degree2(draw.plot=TRUE)

persp(Sepal.L.:Petal.L.) theta -35 ylim 1 3 cex 0.66
persp(Sepal.L.:Petal.W.) theta -35 ylim 1 3 cex 0.66
persp(Sepal.W.:Petal.L.) theta 55 ylim 1 3 cex 0.66
persp(Sepal.W.:Petal.W.) theta 55 ylim 1 3 cex 0.66
persp(Petal.L.:Petal.W.) theta -35 ylim 1 3 cex 0.66

> plotmo(ir.nn2, nresponse=2, clip=F, all2=T, degree2=1:5)

 grid:    Sepal.L. Sepal.W. Petal.L. Petal.W.
               5.8        3      4.4      1.3

> 
> #--- fda ------------------------------------------------------------------------------
> 
> par(mfrow=c(1,1))
> 
> par(mfrow=c(4,5))
> par(mar = c(3, 2, 3, .1)) # b, l, t, r
> par(mgp = c(1.5, .5, 0))
> fda.earth <- fda(Species~., data=iris, keep.fitted=TRUE, method=earth, keepxy=TRUE, trace=0)
> fda.polyreg <- fda(Species~., data=iris, keep.fitted=TRUE, keepxy=TRUE)
> fda.bruto <- fda(Species~., data=iris, keep.fitted=TRUE, method=bruto)
> 
> # this object is nor supported by plotmo
> expect.err(try(plotmo(fda.polyreg$fit, type="variates", nresponse=1, clip=F, do.par=F)))
Error : "polyreg" objects are not supported by plotmo
Got error as expected
> 
> plot(1, main="plotmo with fda", xaxt="n", yaxt="n", xlab="", ylab="",
+      type="n", bty="n", cex.main=1.2, xpd=NA)
> 
> plotmo(fda.earth, type="variates", nresponse=1, clip=F, do.par=F)

 grid:    Sepal.Length Sepal.Width Petal.Length Petal.Width
                   5.8           3         4.35         1.3

> 
> plot(1, main="plotmo with fda.earth$fit", xaxt="n", yaxt="n", xlab="", ylab="",
+      type="n", bty="n", cex.main=1.2, xpd=NA)
> 
> plotmo(fda.earth$fit, nresponse=1, clip=F, do.par=F)

 grid:    Sepal.Length Sepal.Width Petal.Length Petal.Width
                   5.8           3         4.35         1.3

> 
> plot(1, main="", xaxt="n", yaxt="n", xlab="", ylab="",
+      type="n", bty="n", cex.main=1.5, xpd=NA)
> 
> plot(fda.earth)
> plotmo(fda.earth, clip=F, do.par=F, trace=2) # default type is class
Using env attr(object$terms, ".Environment")

--get.plotmo.x for fda object

formula Species ~ .
stripped formula Species~.
get.data.for.formula: using x from "iris" passed to fda 
about to eval model.frame(formula=Species~., data=structure(list(Sepal.Length=c(5.1, 
    4.9, 4.7, 4.6, 5, 5.4, 4.6, 5, 4.4, 4.9, 5.4, 4.8, 4.8, 4.3, 
    5.8, 5.7, 5.4, 5.1, 5.7, 5.1, 5.4, 5.1, 4.6, 5.1, 4.8, 5, 5, 
    5.2, 5.2, 4.7, 4.8, 5.4, 5.2, 5.5, 4.9, 5, 5.5, 4.9, 4.4, 5.1, 
    5, 4.5, 4.4, 5, 5.1, 4.8, 5.1, 4.6, 5.3, 5, 7, 6.4, 6.9, 5.5, 
    6.5, 5.7, 6.3, 4.9, 6.6, 5.2, 5, 5.9, 6, 6.1, 5.6, 6.7, 5.6, 
    5.8, 6.2, 5.6, 5.9, 6.1, 6.3, 6.1, 6.4, 6.6, 6.8, 6.7, 6, 5.7, 
    5.5, 5.5, 5.8, 6, 5.4, 6, 6.7, 6.3, 5.6, 5.5, 5.5, 6.1, 5.8, ...
got x with colnames from object$call$formula

x[150,4]:
    Sepal.Length Sepal.Width Petal.Length Petal.Width
1            5.1         3.5          1.4         0.2
2            4.9         3.0          1.4         0.2
3            4.7         3.2          1.3         0.2
...          4.6         3.1          1.5         0.2
150          5.9         3.0          5.1         1.8

nlevels: Sepal.Length=35 Sepal.Width=23 Petal.Length=43 Petal.Width=22 

--get.plotmo.y for fda object

formula Species ~ .
stripped formula Species~.
get.data.for.formula: using y from "iris" passed to fda 
about to eval model.frame(formula=Species~., data=structure(list(Sepal.Length=c(5.1, 
    4.9, 4.7, 4.6, 5, 5.4, 4.6, 5, 4.4, 4.9, 5.4, 4.8, 4.8, 4.3, 
    5.8, 5.7, 5.4, 5.1, 5.7, 5.1, 5.4, 5.1, 4.6, 5.1, 4.8, 5, 5, 
    5.2, 5.2, 4.7, 4.8, 5.4, 5.2, 5.5, 4.9, 5, 5.5, 4.9, 4.4, 5.1, 
    5, 4.5, 4.4, 5, 5.1, 4.8, 5.1, 4.6, 5.3, 5, 7, 6.4, 6.9, 5.5, 
    6.5, 5.7, 6.3, 4.9, 6.6, 5.2, 5, 5.9, 6, 6.1, 5.6, 6.7, 5.6, 
    5.8, 6.2, 5.6, 5.9, 6.1, 6.3, 6.1, 6.4, 6.6, 6.8, 6.7, 6, 5.7, 
    5.5, 5.5, 5.8, 6, 5.4, 6, 6.7, 6.3, 5.6, 5.5, 5.5, 6.1, 5.8, ...
got y from object$call$formula
get.plotmo.y returned length 150 min 1 max 3
             value 1 1 1 1 1 1 1 1 1 1 ...

--get.plotmo.singles for fda object

singles: 1 Sepal.Length, 2 Sepal.Width, 3 Petal.Length, 4 Petal.Width 

--get.plotmo.pairs for fda object

get.data.for.formula: using x from "iris" passed to fda 
term.labels: Sepal.Length Sepal.Width Petal.Length Petal.Width 
considering Sepal.Length
considering Sepal.Width
considering Petal.Length
considering Petal.Width
no pairs

--plot.degree1(draw.plot=FALSE)

plotmo.predict(type="class") for degree1 plot "Sepal.Length" with newdata[35,4]:
    Sepal.Length Sepal.Width Petal.Length Petal.Width
1            4.3           3         4.35         1.3
2            4.4           3         4.35         1.3
3            4.5           3         4.35         1.3
...          4.6           3         4.35         1.3
35           7.9           3         4.35         1.3

predict.fda(xgrid, type="class") returned length 35 min 2 max 2
                                 value 2 2 2 2 2 2 2 2 2 2 ...

plotmo.predict(type="class") for degree1 plot "Sepal.Width" with newdata[23,4]:
    Sepal.Length Sepal.Width Petal.Length Petal.Width
1            5.8         2.0         4.35         1.3
2            5.8         2.2         4.35         1.3
3            5.8         2.3         4.35         1.3
...          5.8         2.4         4.35         1.3
23           5.8         4.4         4.35         1.3

predict.fda(xgrid, type="class") returned length 23 min 2 max 2
                                 value 2 2 2 2 2 2 2 2 2 2 ...

plotmo.predict(type="class") for degree1 plot "Petal.Length" with newdata[43,4]:
    Sepal.Length Sepal.Width Petal.Length Petal.Width
1            5.8           3          1.0         1.3
2            5.8           3          1.1         1.3
3            5.8           3          1.2         1.3
...          5.8           3          1.3         1.3
43           5.8           3          6.9         1.3

predict.fda(xgrid, type="class") returned length 43 min 1 max 3
                                 value 1 1 1 1 1 1 1 1 1 2 ...

plotmo.predict(type="class") for degree1 plot "Petal.Width" with newdata[22,4]:
    Sepal.Length Sepal.Width Petal.Length Petal.Width
1            5.8           3         4.35         0.1
2            5.8           3         4.35         0.2
3            5.8           3         4.35         0.3
...          5.8           3         4.35         0.4
22           5.8           3         4.35         2.5

predict.fda(xgrid, type="class") returned length 22 min 2 max 3
                                 value 2 2 2 2 2 2 2 2 2 2 ...

ylim 1 3 

--plot.degree1(draw.plot=TRUE)

 grid:    Sepal.Length Sepal.Width Petal.Length Petal.Width
                   5.8           3         4.35         1.3

> 
> plot(fda.polyreg)
> plotmo(fda.polyreg, type="variates", nresponse=1, clip=F, do.par=F, trace=2, degree1=c(1,3,4))
Using env attr(object$terms, ".Environment")

--get.plotmo.x for fda object

formula Species ~ .
stripped formula Species~.
get.data.for.formula: using x from "iris" passed to fda 
about to eval model.frame(formula=Species~., data=structure(list(Sepal.Length=c(5.1, 
    4.9, 4.7, 4.6, 5, 5.4, 4.6, 5, 4.4, 4.9, 5.4, 4.8, 4.8, 4.3, 
    5.8, 5.7, 5.4, 5.1, 5.7, 5.1, 5.4, 5.1, 4.6, 5.1, 4.8, 5, 5, 
    5.2, 5.2, 4.7, 4.8, 5.4, 5.2, 5.5, 4.9, 5, 5.5, 4.9, 4.4, 5.1, 
    5, 4.5, 4.4, 5, 5.1, 4.8, 5.1, 4.6, 5.3, 5, 7, 6.4, 6.9, 5.5, 
    6.5, 5.7, 6.3, 4.9, 6.6, 5.2, 5, 5.9, 6, 6.1, 5.6, 6.7, 5.6, 
    5.8, 6.2, 5.6, 5.9, 6.1, 6.3, 6.1, 6.4, 6.6, 6.8, 6.7, 6, 5.7, 
    5.5, 5.5, 5.8, 6, 5.4, 6, 6.7, 6.3, 5.6, 5.5, 5.5, 6.1, 5.8, ...
got x with colnames from object$call$formula

x[150,4]:
    Sepal.Length Sepal.Width Petal.Length Petal.Width
1            5.1         3.5          1.4         0.2
2            4.9         3.0          1.4         0.2
3            4.7         3.2          1.3         0.2
...          4.6         3.1          1.5         0.2
150          5.9         3.0          5.1         1.8

nlevels: Sepal.Length=35 Sepal.Width=23 Petal.Length=43 Petal.Width=22 

--get.plotmo.y for fda object

formula Species ~ .
stripped formula Species~.
get.data.for.formula: using y from "iris" passed to fda 
about to eval model.frame(formula=Species~., data=structure(list(Sepal.Length=c(5.1, 
    4.9, 4.7, 4.6, 5, 5.4, 4.6, 5, 4.4, 4.9, 5.4, 4.8, 4.8, 4.3, 
    5.8, 5.7, 5.4, 5.1, 5.7, 5.1, 5.4, 5.1, 4.6, 5.1, 4.8, 5, 5, 
    5.2, 5.2, 4.7, 4.8, 5.4, 5.2, 5.5, 4.9, 5, 5.5, 4.9, 4.4, 5.1, 
    5, 4.5, 4.4, 5, 5.1, 4.8, 5.1, 4.6, 5.3, 5, 7, 6.4, 6.9, 5.5, 
    6.5, 5.7, 6.3, 4.9, 6.6, 5.2, 5, 5.9, 6, 6.1, 5.6, 6.7, 5.6, 
    5.8, 6.2, 5.6, 5.9, 6.1, 6.3, 6.1, 6.4, 6.6, 6.8, 6.7, 6, 5.7, 
    5.5, 5.5, 5.8, 6, 5.4, 6, 6.7, 6.3, 5.6, 5.5, 5.5, 6.1, 5.8, ...
got y from object$call$formula
get.plotmo.y returned length 150 min 1 max 3
             value 1 1 1 1 1 1 1 1 1 1 ...

--get.plotmo.singles for fda object

singles: 1 Sepal.Length, 3 Petal.Length, 4 Petal.Width 

--get.plotmo.pairs for fda object

get.data.for.formula: using x from "iris" passed to fda 
term.labels: Sepal.Length Sepal.Width Petal.Length Petal.Width 
considering Sepal.Length
considering Sepal.Width
considering Petal.Length
considering Petal.Width
no pairs

--plot.degree1(draw.plot=FALSE)

plotmo.predict(type="variates") for degree1 plot "Sepal.Length" with newdata[35,4]:
    Sepal.Length Sepal.Width Petal.Length Petal.Width
1            4.3           3         4.35         1.3
2            4.4           3         4.35         1.3
3            4.5           3         4.35         1.3
...          4.6           3         4.35         1.3
35           7.9           3         4.35         1.3

predict.fda(xgrid, type="variates") returned length 35 min -0.03206216 max 2.98401
                                    value 2.98401 2.900231 2.816451 2.732671 2.648891 2.565111 2.481332 2.397552 2.313772 2.229992 ...

plotmo.predict(type="variates") for degree1 plot "Petal.Length" with newdata[43,4]:
    Sepal.Length Sepal.Width Petal.Length Petal.Width
1            5.8           3          1.0         1.3
2            5.8           3          1.1         1.3
3            5.8           3          1.2         1.3
...          5.8           3          1.3         1.3
43           5.8           3          6.9         1.3

predict.fda(xgrid, type="variates") returned length 43 min -5.721611 max 7.39739
                                    value -5.721611 -5.499255 -5.276899 -5.054543 -4.832187 -4.609831 -4.387475 -4.165119 -3.720407 -1.274492 ...

plotmo.predict(type="variates") for degree1 plot "Petal.Width" with newdata[22,4]:
    Sepal.Length Sepal.Width Petal.Length Petal.Width
1            5.8           3         4.35         0.1
2            5.8           3         4.35         0.2
3            5.8           3         4.35         0.3
...          5.8           3         4.35         0.4
22           5.8           3         4.35         2.5

predict.fda(xgrid, type="variates") returned length 22 min -1.679479 max 5.134106
                                    value -1.679479 -1.395579 -1.11168 -0.8277808 -0.5438814 -0.259982 0.8756154 1.159515 1.443414 1.727314 ...

ylim -5.721611 7.39739 

--plot.degree1(draw.plot=TRUE)

 grid:    Sepal.Length Sepal.Width Petal.Length Petal.Width
                   5.8           3         4.35         1.3

> plot(1, main="", xaxt="n", yaxt="n", xlab="", ylab="",
+      type="n", bty="n", cex.main=1.5, xpd=NA)
> 
> # plot(fda.bruto)
> # plotmo(fda.bruto, type="variates", nresponse=1, clip=F, do.par=F)
> 
> if(!interactive()) {
+     dev.off()         # finish postscript plot
+     q(runLast=FALSE)  # needed else R prints the time on exit (R2.5 and higher) which messes up the diffs
+ }
